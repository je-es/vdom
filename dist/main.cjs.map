{"version":3,"sources":["../src/utils/helpers.ts","../src/utils/errors.ts","../src/core/createElement.ts","../src/core/html.ts","../src/core/props.ts","../src/core/render.ts","../src/core/patch.ts"],"names":["isNullOrBoolean","value","isVNode","isPrimitive","flattenChildren","children","flattened","child","sanitizeHTML","html","dangerous","sanitized","pattern","camelToKebab","str","shallowEqual","a","b","keysA","keysB","key","idCounter","generateId","prefix","isBrowser","getChildAt","parent","index","isFunction","isEventProp","propName","getEventName","deepClone","obj","cloned","config","setConfig","newConfig","getConfig","VDOMError","message","vnode","context","handleError","error","vdomError","handlerError","warn","assert","condition","createErrorPlaceholder","validateVNode","withErrorHandling","fn","args","createElement","type","props","flatChildren","normalizedProps","Fragment","h","jsx","jsxs","jsxDEV","MARKERS","strings","values","htmlString","i","isInAttribute","marker","createMarker","parseHTML","applyEventHandlers","handler","lastEqualIndex","lastGtIndex","processedHTML","eventMarkerProtection","protectionIndex","match","eventName","placeholder","original","template","element","result","convertDOMToVNode","handleTextNode","el","parseAttributes","parseChildren","text","array","item","processedText","attributes","attr","name","replaceMarkers","replaced","childNodes","foundArray","foundVNodes","converted","valueMap","BOOLEAN_ATTRS","updateProps","oldProps","newProps","removeProperty","setProperty","oldValue","setEventListener","setClassName","setStyle","setBooleanAttribute","setAttribute","oldHandler","className","prop","val","attrName","createDOMElement","createFragment","createRegularElement","fragment","childElement","render","container","patchChild","oldChild","newChild","node","oldVNode","patch","patchChildrenByIndex","oldChildren","newChildren","maxLength","c","lastChild","patchChildrenWithKeys","oldKeyMap","domElements","elementIndex","newElements","textNode","newVNode","oldChildrenArray","newChildrenArray","newElement","patchChildren","addNode","removeNode","updateTextNode","oldText","newText","oldStr","newStr","replaceNode","hasVNodeChanged","updateElement","elementToUpdate","parentMatchesVNode","childIsDifferentType","updateNode"],"mappings":"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","file":"main.cjs","sourcesContent":["// src/utils/helpers.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNodeChild } from '../types';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Check if value should be skipped in rendering\n     */\n    export function isNullOrBoolean(value: any): value is false | null | undefined | true {\n        return value === false || value === null || value === undefined || value === true;\n    }\n\n    /**\n     * Check if value is a VNode\n     * FIX: Return false for null instead of null\n     */\n    export function isVNode(value: any): boolean {\n        if (!value || typeof value !== 'object') {\n            return false;\n        }\n        return 'type' in value && 'props' in value && 'children' in value;\n    }\n\n    /**\n     * Check if value is a primitive that can be rendered\n     */\n    export function isPrimitive(value: any): value is string | number {\n        return typeof value === 'string' || typeof value === 'number';\n    }\n\n    /**\n     * Flatten nested children arrays recursively\n     */\n    export function flattenChildren(children: any[]): VNodeChild[] {\n        const flattened: VNodeChild[] = [];\n\n        for (const child of children) {\n            if (Array.isArray(child)) {\n                flattened.push(...flattenChildren(child));\n            } else if (!isNullOrBoolean(child)) {\n                flattened.push(child);\n            }\n        }\n\n        return flattened;\n    }\n\n    /**\n     * Sanitize HTML to prevent XSS attacks\n     */\n    export function sanitizeHTML(html: string): string {\n        // Remove dangerous patterns\n        const dangerous = [\n            /<script[\\s\\S]*?<\\/script>/gi,\n            /javascript:/gi,\n            /on\\w+\\s*=/gi, // inline event handlers like onerror=\n            /<iframe[\\s\\S]*?<\\/iframe>/gi,\n            /<object[\\s\\S]*?<\\/object>/gi,\n            /<embed[\\s\\S]*?>/gi,\n        ];\n\n        let sanitized = html;\n        for (const pattern of dangerous) {\n            sanitized = sanitized.replace(pattern, '');\n        }\n\n        return sanitized;\n    }\n\n    /**\n     * Convert camelCase to kebab-case\n     */\n    export function camelToKebab(str: string): string {\n        return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n    }\n\n    /**\n     * Check if two values are equal (shallow comparison)\n     */\n    export function shallowEqual(a: any, b: any): boolean {\n        if (a === b) return true;\n        if (typeof a !== typeof b) return false;\n        if (typeof a !== 'object' || a === null || b === null) return false;\n\n        const keysA = Object.keys(a);\n        const keysB = Object.keys(b);\n\n        if (keysA.length !== keysB.length) return false;\n\n        for (const key of keysA) {\n            if (a[key] !== b[key]) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Generate unique ID\n     */\n    let idCounter = 0;\n    export function generateId(prefix = 'vdom'): string {\n        return `${prefix}-${++idCounter}-${Date.now()}`;\n    }\n\n    /**\n     * Check if code is running in browser environment\n     */\n    export function isBrowser(): boolean {\n        return typeof window !== 'undefined' && typeof document !== 'undefined';\n    }\n\n    /**\n     * Safe way to get element from parent by index\n     */\n    export function getChildAt(parent: HTMLElement, index: number): Node | undefined {\n        return parent.childNodes[index] as Node | undefined;\n    }\n\n    /**\n     * Check if value is a function\n     */\n    export function isFunction(value: any): value is Function {\n        return typeof value === 'function';\n    }\n\n    /**\n     * Check if string is an event handler prop name\n     */\n    export function isEventProp(propName: string): boolean {\n        return propName.startsWith('on') && propName.length > 2;\n    }\n\n    /**\n     * Get event name from prop name (onclick -> click)\n     */\n    export function getEventName(propName: string): string {\n        return propName.substring(2).toLowerCase();\n    }\n\n    /**\n     * Deep clone object (simple implementation)\n     */\n    export function deepClone<T>(obj: T): T {\n        if (obj === null || typeof obj !== 'object') return obj;\n        if (Array.isArray(obj)) return obj.map(deepClone) as any;\n\n        const cloned: any = {};\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                cloned[key] = deepClone(obj[key]);\n            }\n        }\n        return cloned;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/utils/errors.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode, VDOMConfig } from '../types';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Global configuration\n     */\n    let config: VDOMConfig = {\n        devMode: process.env.NODE_ENV !== 'production',\n        sanitizeHTML: true,\n        onError: undefined,\n    };\n\n    /**\n     * Set global configuration\n     */\n    export function setConfig(newConfig: Partial<VDOMConfig>): void {\n        config = { ...config, ...newConfig };\n    }\n\n    /**\n     * Get current configuration\n     */\n    export function getConfig(): VDOMConfig {\n        return { ...config };\n    }\n\n    /**\n     * Custom error class for VDOM errors\n     */\n    export class VDOMError extends Error {\n        constructor(\n            message: string,\n            public vnode?: VNode,\n            public context?: string\n        ) {\n            super(message);\n            this.name = 'VDOMError';\n        }\n    }\n\n    /**\n     * Handle errors with custom error handler if provided\n     */\n    export function handleError(error: Error, vnode?: VNode, context?: string): void {\n        const vdomError = error instanceof VDOMError \n            ? error \n            : new VDOMError(error.message, vnode, context);\n\n        if (config.onError) {\n            try {\n                config.onError(vdomError, vnode);\n            } catch (handlerError) {\n                console.error('Error in custom error handler:', handlerError);\n                console.error('Original error:', vdomError);\n            }\n        } else {\n            console.error('VDOM Error:', vdomError.message);\n            if (config.devMode && vnode) {\n                console.error('VNode:', vnode);\n                if (context) console.error('Context:', context);\n            }\n        }\n    }\n\n    /**\n     * Warning function (only in dev mode)\n     */\n    export function warn(message: string, vnode?: VNode): void {\n        if (config.devMode) {\n            console.warn(`[VDOM Warning]: ${message}`);\n            if (vnode) console.warn('VNode:', vnode);\n        }\n    }\n\n    /**\n     * Assert function for development checks\n     */\n    export function assert(condition: boolean, message: string): void {\n        if (config.devMode && !condition) {\n            throw new VDOMError(`Assertion failed: ${message}`);\n        }\n    }\n\n    /**\n     * Create error placeholder element\n     */\n    export function createErrorPlaceholder(error: Error): Text {\n        const message = config.devMode \n            ? `[Render Error: ${error.message}]`\n            : '[Render Error]';\n        return document.createTextNode(message);\n    }\n\n    /**\n     * Validate VNode structure\n     */\n    export function validateVNode(vnode: any): vnode is VNode {\n        if (!vnode || typeof vnode !== 'object') {\n            return false;\n        }\n\n        if (!('type' in vnode && 'props' in vnode && 'children' in vnode)) {\n            if (config.devMode) {\n                warn('Invalid VNode structure: missing required properties (type, props, children)', vnode);\n            }\n            return false;\n        }\n\n        if (typeof vnode.type !== 'string') {\n            if (config.devMode) {\n                warn('Invalid VNode type: must be a string', vnode);\n            }\n            return false;\n        }\n\n        if (!Array.isArray(vnode.children)) {\n            if (config.devMode) {\n                warn('Invalid VNode children: must be an array', vnode);\n            }\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Wrap function with error handling\n     */\n    export function withErrorHandling<T extends (...args: any[]) => any>(\n        fn: T,\n        context?: string\n    ): T {\n        return ((...args: any[]) => {\n            try {\n                return fn(...args);\n            } catch (error) {\n                handleError(error as Error, undefined, context);\n                return null;\n            }\n        }) as T;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/createElement.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode, VNodeProps, VNodeChild } from '../types';\n    import { flattenChildren } from '../utils/helpers';\n    import { warn } from '../utils/errors';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Create a Virtual Node\n     * \n     * @param type - Element type or 'fragment'\n     * @param props - Element properties\n     * @param children - Child elements\n     * @returns VNode\n     * \n     * @example\n     * ```ts\n     * const vnode = createElement('div', { className: 'box' }, 'Hello World');\n     * ```\n     */\n    export function createElement(\n        type: string | 'fragment',\n        props: VNodeProps | null,\n        ...children: any[]\n    ): VNode {\n        // Validate type in development\n        if (process.env.NODE_ENV !== 'production') {\n            if (!type || typeof type !== 'string') {\n                warn(`Invalid element type: ${type}`);\n            }\n        }\n\n        const flatChildren = flattenChildren(children);\n\n        // Handle fragments\n        if (type === 'fragment') {\n            return {\n                type: 'fragment',\n                props: {},\n                children: flatChildren,\n            };\n        }\n\n        // Handle class vs className\n        const normalizedProps = props ? { ...props } : {};\n        if (normalizedProps.class && !normalizedProps.className) {\n            normalizedProps.className = normalizedProps.class;\n            delete normalizedProps.class;\n        }\n\n        return {\n            type,\n            props: normalizedProps,\n            children: flatChildren,\n        };\n    }\n\n    /**\n     * Create a fragment (wrapper for multiple children without parent element)\n     * \n     * @param children - Child elements\n     * @returns VNode with type 'fragment'\n     * \n     * @example\n     * ```ts\n     * const frag = Fragment(\n     *   createElement('div', {}, 'First'),\n     *   createElement('div', {}, 'Second')\n     * );\n     * ```\n     */\n    export function Fragment(...children: VNodeChild[]): VNode {\n        return createElement('fragment', null, ...children);\n    }\n\n    /**\n     * Create a text node\n     * \n     * @param text - Text content\n     * @returns String that will be rendered as text\n     */\n    export function createTextNode(text: string | number): string {\n        return String(text);\n    }\n\n    /**\n     * JSX Factory function (for JSX pragma)\n     * Alias for createElement to be used with JSX\n     */\n    export const h = createElement;\n\n    /**\n     * JSX Fragment factory\n     */\n    export const jsx = createElement;\n    export const jsxs = createElement;\n    export const jsxDEV = createElement;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/html.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode, ParseContext } from '../types';\n    import { isNullOrBoolean } from '../utils/helpers';\n    import { sanitizeHTML } from '../utils/helpers';\n    import { getConfig } from '../utils/errors';\n    import { createElement } from './createElement';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Markers for identifying interpolated values\n     */\n    const MARKERS = {\n        EVENT: '__EVENT_',\n        VNODE: '__VNODE_',\n        ARRAY: '__ARRAY_',\n        VALUE: '__VALUE_'\n    } as const;\n\n    /**\n     * HTML tagged template literal\n     * Creates VNodes from HTML template strings with interpolated values\n     * \n     * FIX: Store event handlers separately and apply after parsing to avoid HTML parser issues\n     */\n    export function html(\n        strings: TemplateStringsArray,\n        ...values: any[]\n    ): VNode {\n        const context: ParseContext = {\n            eventHandlers: new Map(),\n            vnodes: new Map(),\n            arrays: new Map(),\n            plainValues: new Map(),\n        };\n\n        let htmlString = '';\n\n        // Build HTML string and store values\n        for (let i = 0; i < strings.length; i++) {\n            const str = strings[i];\n            htmlString += str;\n\n            if (i < values.length) {\n                const value = values[i];\n\n                if (isNullOrBoolean(value)) {\n                    if (value === false && isInAttribute(str)) {\n                        htmlString += 'false';\n                    }\n                    continue;\n                }\n\n                const marker = createMarker(value, i, context);\n                htmlString += marker;\n            }\n        }\n\n        const vnode = parseHTML(htmlString, context);\n\n        // Apply event handlers from context to the VNode\n        applyEventHandlers(vnode, context);\n\n        return vnode;\n    }\n\n    /**\n     * Apply stored event handlers to VNode props\n     * Recursively searches for event handler markers and replaces them with actual functions\n     */\n    function applyEventHandlers(vnode: VNode, context: ParseContext): void {\n        // Check props for event handler markers and replace them\n        for (const [key, value] of Object.entries(vnode.props)) {\n            if (key.startsWith('on') && typeof value === 'string') {\n                // The value should be the event marker like \"__EVENT_0__\"\n                // Try exact match first\n                if (context.eventHandlers.has(value)) {\n                    vnode.props[key] = context.eventHandlers.get(value);\n                    continue;\n                }\n                \n                // If not exact match, try finding any marker that's contained in the value\n                for (const [marker, handler] of context.eventHandlers) {\n                    if (value.includes(marker)) {\n                        vnode.props[key] = handler;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Recursively apply to children\n        for (const child of vnode.children) {\n            if (child && typeof child === 'object' && 'type' in child) {\n                applyEventHandlers(child as VNode, context);\n            }\n        }\n    }\n\n    /**\n     * Check if we're currently inside an attribute VALUE (not name)\n     */\n    function isInAttribute(str: string): boolean {\n        const lastEqualIndex = str.lastIndexOf('=');\n        const lastGtIndex = str.lastIndexOf('>');\n        return lastEqualIndex > lastGtIndex;\n    }\n\n    /**\n     * Create appropriate marker for value type\n     */\n    function createMarker(value: any, index: number, context: ParseContext): string {\n        // Arrays\n        if (Array.isArray(value)) {\n            const marker = `${MARKERS.ARRAY}${index}__`;\n            context.arrays.set(marker, value);\n            return marker;\n        }\n\n        // Functions (event handlers)\n        if (typeof value === 'function') {\n            const marker = `${MARKERS.EVENT}${index}__`;\n            context.eventHandlers.set(marker, value);\n            return marker;\n        }\n\n        // VNodes\n        if (value && typeof value === 'object' && 'type' in value) {\n            const marker = `${MARKERS.VNODE}${index}__`;\n            context.vnodes.set(marker, value);\n            return marker;\n        }\n\n        // Plain values\n        const marker = `${MARKERS.VALUE}${index}__`;\n        context.plainValues.set(marker, value);\n        return marker;\n    }\n\n    /**\n     * Parse HTML string to VNode\n     */\n    function parseHTML(html: string, context: ParseContext): VNode {\n        const config = getConfig();\n\n        let processedHTML = html.trim();\n        \n        if (config.sanitizeHTML) {\n            // CRITICAL FIX: Protect event markers BEFORE sanitization\n            // The sanitizer removes onclick=\"...\" attributes, so we need to protect our markers\n            const eventMarkerProtection: Array<{ placeholder: string; original: string }> = [];\n            let protectionIndex = 0;\n            \n            // Replace onclick=\"__EVENT_N__\" with a safe placeholder\n            processedHTML = processedHTML.replace(/\\s+(on\\w+)=\"(__EVENT_\\d+__)\"/g, (match, eventName, marker) => {\n                const placeholder = `data-vdom-event-${protectionIndex}=\"${marker}\"`;\n                eventMarkerProtection.push({ placeholder, original: match });\n                protectionIndex++;\n                return ` ${placeholder}`;\n            });\n\n            // Also handle onclick=__EVENT_N__ (without quotes)\n            processedHTML = processedHTML.replace(/\\s+(on\\w+)=(__EVENT_\\d+__)/g, (match, eventName, marker) => {\n                const placeholder = `data-vdom-event-${protectionIndex}=\"${marker}\"`;\n                eventMarkerProtection.push({ placeholder, original: match });\n                protectionIndex++;\n                return ` ${placeholder}`;\n            });\n\n            // Now sanitize\n            processedHTML = sanitizeHTML(processedHTML);\n\n            // Restore event markers\n            for (const { placeholder, original } of eventMarkerProtection) {\n                processedHTML = processedHTML.replace(placeholder, original);\n            }\n        }\n\n        const template = document.createElement('template');\n        template.innerHTML = processedHTML;\n\n        const element = template.content.firstChild as HTMLElement;\n\n        if (!element) {\n            return createElement('div', {}, '');\n        }\n\n        const result = convertDOMToVNode(element, context);\n\n        // If result is a string (text node), wrap it in a span\n        if (typeof result === 'string') {\n            return createElement('span', {}, result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Convert DOM node to VNode\n     */\n    function convertDOMToVNode(element: Node, context: ParseContext): VNode | string {\n        // Text nodes\n        if (element.nodeType === Node.TEXT_NODE) {\n            return handleTextNode(element.textContent || '', context);\n        }\n\n        // Skip non-element nodes\n        if (element.nodeType !== Node.ELEMENT_NODE) {\n            return '';\n        }\n\n        const el = element as HTMLElement;\n        const props = parseAttributes(el.attributes, context);\n        const children = parseChildren(el.childNodes, context);\n\n        return {\n            type: el.tagName.toLowerCase(),\n            props,\n            children,\n        };\n    }\n\n    /**\n     * Handle text node with markers\n     */\n    function handleTextNode(text: string, context: ParseContext): VNode | string {\n        // Check for array markers\n        for (const [marker, array] of context.arrays) {\n            if (text.includes(marker)) {\n                return {\n                    type: 'fragment',\n                    props: {},\n                    children: array.filter(item => !isNullOrBoolean(item))\n                };\n            }\n        }\n\n        // Check for VNode markers\n        for (const [marker, vnode] of context.vnodes) {\n            if (text.includes(marker)) {\n                return vnode;\n            }\n        }\n\n        // Replace value markers\n        let processedText = text;\n        for (const [marker, value] of context.plainValues) {\n            processedText = processedText.replace(marker, String(value));\n        }\n\n        return processedText;\n    }\n\n    /**\n     * Parse element attributes\n     * IMPORTANT: Just store the raw marker values for event handlers\n     * We'll replace them with actual functions in applyEventHandlers\n     */\n    function parseAttributes(\n        attributes: NamedNodeMap,\n        context: ParseContext\n    ): Record<string, any> {\n        const props: Record<string, any> = {};\n\n        for (const attr of Array.from(attributes)) {\n            const { name, value } = attr;\n\n            // Event handlers - keep the marker string as-is\n            // It will be replaced by applyEventHandlers later\n            if (name.startsWith('on')) {\n                props[name] = value;\n                continue;\n            }\n\n            // Class names\n            if (name === 'class') {\n                props.className = replaceMarkers(value, context.plainValues).trim();\n                continue;\n            }\n\n            // Boolean attributes\n            if (name === 'checked' || name === 'disabled' || name === 'selected' || name === 'required') {\n                const replaced = replaceMarkers(value, context.plainValues);\n\n                if (replaced === 'false') {\n                    continue;\n                } else if (replaced === 'true' || replaced === '') {\n                    props[name] = true;\n                } else {\n                    props[name] = replaced;\n                }\n                continue;\n            }\n\n            // Regular attributes\n            props[name] = replaceMarkers(value, context.plainValues);\n        }\n\n        return props;\n    }\n\n    /**\n     * Parse child nodes\n     */\n    function parseChildren(childNodes: NodeListOf<ChildNode>, context: ParseContext): any[] {\n        const children: any[] = [];\n\n        for (const child of Array.from(childNodes)) {\n            if (child.nodeType === Node.TEXT_NODE) {\n                const text = child.textContent || '';\n\n                // Check for array markers\n                let foundArray = false;\n                for (const [marker, array] of context.arrays) {\n                    if (text.includes(marker)) {\n                        children.push(...array.filter(item => !isNullOrBoolean(item)));\n                        foundArray = true;\n                        break;\n                    }\n                }\n                if (foundArray) continue;\n\n                // Check for VNode markers\n                const foundVNodes: any[] = [];\n                for (const [marker, vnode] of context.vnodes) {\n                    if (text.includes(marker)) {\n                        if (vnode && typeof vnode === 'object' && 'type' in vnode) {\n                            foundVNodes.push(vnode);\n                        }\n                    }\n                }\n                if (foundVNodes.length > 0) {\n                    children.push(...foundVNodes);\n                    continue;\n                }\n\n                // Add processed text\n                if (text.trim()) {\n                    const processedText = replaceMarkers(text, context.plainValues);\n                    if (processedText.trim()) {\n                        children.push(processedText);\n                    }\n                }\n            } else if (child.nodeType === Node.ELEMENT_NODE) {\n                const converted = convertDOMToVNode(child, context);\n                if (converted) children.push(converted);\n            }\n        }\n\n        return children;\n    }\n\n    /**\n     * Replace markers in string with actual values\n     */\n    function replaceMarkers(str: string, valueMap: Map<string, any>): string {\n        let result = str;\n        for (const [marker, value] of valueMap) {\n            result = result.replace(marker, String(value));\n        }\n        return result;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/props.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNodeProps, StyleObject } from '../types';\n    import { isEventProp, getEventName, isFunction } from '../utils/helpers';\n    import { warn } from '../utils/errors';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Special props that need custom handling\n     */\n    const SPECIAL_PROPS = new Set([\n        'key',\n        'ref',\n        'children',\n        'className',\n        'class',\n        'style',\n        'dangerouslySetInnerHTML'\n    ]);\n\n    /**\n     * Boolean attributes that work differently\n     */\n    const BOOLEAN_ATTRS = new Set([\n        'checked',\n        'selected',\n        'disabled',\n        'readOnly',\n        'required',\n        'autoFocus',\n        'multiple',\n        'hidden',\n        'autoplay',\n        'controls',\n        'loop',\n        'muted',\n        'open',\n        'reversed'\n    ]);\n\n    /**\n     * Update element properties\n     */\n    export function updateProps(\n        element: HTMLElement,\n        oldProps: VNodeProps,\n        newProps: VNodeProps\n    ): void {\n        // Remove old props\n        for (const key in oldProps) {\n            if (!(key in newProps)) {\n                removeProperty(element, key, oldProps[key]);\n            }\n        }\n\n        // Set new props\n        for (const [key, value] of Object.entries(newProps)) {\n            if (oldProps[key] !== value) {\n                setProperty(element, key, value, oldProps[key]);\n            }\n        }\n    }\n\n    /**\n     * Set a single property on element\n     */\n    export function setProperty(\n        element: HTMLElement,\n        key: string,\n        value: any,\n        oldValue?: any\n    ): void {\n        // Skip special keys\n        if (key === 'children' || key === 'key') return;\n\n        // Event handlers\n        if (isEventProp(key)) {\n            setEventListener(element, key, value, oldValue);\n            return;\n        }\n\n        // Ref callback\n        if (key === 'ref' && isFunction(value)) {\n            value(element);\n            return;\n        }\n\n        // Class name\n        if (key === 'className' || key === 'class') {\n            setClassName(element, value);\n            return;\n        }\n\n        // Style\n        if (key === 'style') {\n            setStyle(element, value);\n            return;\n        }\n\n        // Dangerous HTML\n        if (key === 'dangerouslySetInnerHTML' && value?.__html) {\n            element.innerHTML = value.__html;\n            return;\n        }\n\n        // Boolean attributes\n        if (BOOLEAN_ATTRS.has(key)) {\n            setBooleanAttribute(element, key, value);\n            return;\n        }\n\n        // Regular attributes\n        setAttribute(element, key, value);\n    }\n\n    /**\n     * Remove a property from element\n     */\n    export function removeProperty(element: HTMLElement, key: string, oldValue: any): void {\n        // Event handlers\n        if (isEventProp(key) && isFunction(oldValue)) {\n            const eventName = getEventName(key);\n            element.removeEventListener(eventName, oldValue);\n            return;\n        }\n\n        // Ref\n        if (key === 'ref' && isFunction(oldValue)) {\n            oldValue(null);\n            return;\n        }\n\n        // Class name\n        if (key === 'className' || key === 'class') {\n            element.className = '';\n            element.removeAttribute('class');\n            return;\n        }\n\n        // Style\n        if (key === 'style') {\n            element.removeAttribute('style');\n            return;\n        }\n\n        // Boolean attributes\n        if (BOOLEAN_ATTRS.has(key)) {\n            element.removeAttribute(key.toLowerCase());\n            return;\n        }\n\n        // Regular attributes\n        element.removeAttribute(key);\n    }\n\n    /**\n     * Set event listener\n     */\n    function setEventListener(\n        element: HTMLElement,\n        propName: string,\n        handler: any,\n        oldHandler?: any\n    ): void {\n        if (!isFunction(handler)) {\n            if (process.env.NODE_ENV !== 'production') {\n                warn(`Event handler ${propName} is not a function`);\n            }\n            return;\n        }\n\n        const eventName = getEventName(propName);\n\n        // Remove old handler\n        if (oldHandler && isFunction(oldHandler)) {\n            element.removeEventListener(eventName, oldHandler);\n        }\n\n        // Add new handler\n        element.addEventListener(eventName, handler);\n    }\n\n    /**\n     * Set class name\n     */\n    function setClassName(element: HTMLElement, value: any): void {\n        if (value == null || value === false) {\n            element.className = '';\n            element.removeAttribute('class');\n            return;\n        }\n\n        const className = String(value).trim();\n        if (className) {\n            element.className = className;\n        } else {\n            element.className = '';\n            element.removeAttribute('class');\n        }\n    }\n\n    /**\n     * Set style attribute\n     */\n    function setStyle(element: HTMLElement, value: string | StyleObject | null | undefined): void {\n        if (value == null) {\n            element.removeAttribute('style');\n            return;\n        }\n\n        // String style\n        if (typeof value === 'string') {\n            element.setAttribute('style', value);\n            return;\n        }\n\n        // Object style\n        if (typeof value === 'object') {\n            for (const [prop, val] of Object.entries(value)) {\n                if (val == null) {\n                    (element.style as any)[prop] = '';\n                } else {\n                    (element.style as any)[prop] = val;\n                }\n            }\n        }\n    }\n\n    /**\n     * Set boolean attribute\n     *\n     * FIXED: Treat any value except false, null, undefined as true\n     * This matches HTML spec and common framework behavior\n     * Special case: empty string '' is valid and sets the attribute\n     */\n    function setBooleanAttribute(element: HTMLElement, key: string, value: any): void {\n        const attrName = key.toLowerCase();\n\n        // Explicitly false, null, or undefined removes the attribute\n        if (value === false || value === null || value === undefined) {\n            element.removeAttribute(attrName);\n            return;\n        }\n\n        // Any other value (including empty string '') sets the attribute\n        // This includes: true, 'true', '', 'yes', 'disabled', numbers, etc.\n        element.setAttribute(attrName, '');\n    }\n\n    /**\n     * Set regular attribute\n     */\n    function setAttribute(element: HTMLElement, key: string, value: any): void {\n        if (value == null || value === false) {\n            element.removeAttribute(key);\n            return;\n        }\n\n        // Convert to string and set\n        element.setAttribute(key, String(value));\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/render.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode } from '../types';\n    import { isNullOrBoolean, isPrimitive } from '../utils/helpers';\n    import { handleError, createErrorPlaceholder, validateVNode } from '../utils/errors';\n    import { updateProps } from './props';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Create a real DOM element from a VNode\n     * \n     * @param vnode - Virtual node to convert\n     * @returns HTML element, text node, or document fragment\n     */\n    export function createDOMElement(vnode: VNode | string | number): HTMLElement | Text | DocumentFragment {\n        try {\n            // Handle text nodes (primitives)\n            if (isPrimitive(vnode)) {\n                return document.createTextNode(String(vnode));\n            }\n\n            // Validate VNode structure\n            if (!validateVNode(vnode)) {\n                throw new Error('Invalid VNode structure');\n            }\n\n            // Handle fragments\n            if (vnode.type === 'fragment') {\n                return createFragment(vnode);\n            }\n\n            // Handle regular elements\n            return createRegularElement(vnode);\n\n        } catch (error) {\n            handleError(error as Error, typeof vnode === 'object' ? vnode : undefined, 'createDOMElement');\n            return createErrorPlaceholder(error as Error);\n        }\n    }\n\n    /**\n     * Create a document fragment from VNode\n     */\n    function createFragment(vnode: VNode): DocumentFragment {\n        const fragment = document.createDocumentFragment();\n\n        for (const child of vnode.children) {\n            if (isNullOrBoolean(child)) continue;\n\n            const childElement = isPrimitive(child)\n                ? document.createTextNode(String(child))\n                : createDOMElement(child as VNode);\n\n            fragment.appendChild(childElement);\n        }\n\n        return fragment;\n    }\n\n    /**\n     * Create a regular HTML element from VNode\n     */\n    function createRegularElement(vnode: VNode): HTMLElement {\n        // Create element\n        const element = document.createElement(vnode.type);\n\n        // Set properties\n        updateProps(element, {}, vnode.props);\n\n        // Append children\n        for (const child of vnode.children) {\n            if (isNullOrBoolean(child)) continue;\n\n            const childElement = isPrimitive(child)\n                ? document.createTextNode(String(child))\n                : createDOMElement(child as VNode);\n\n            element.appendChild(childElement);\n        }\n\n        return element;\n    }\n\n    /**\n     * Main render function - renders VNode to container\n     * \n     * @param vnode - Virtual node to render\n     * @param container - Container element\n     * \n     * @example\n     * ```ts\n     * const app = createElement('div', {}, 'Hello World');\n     * render(app, document.getElementById('root')!);\n     * ```\n     */\n    export function render(vnode: VNode, container: HTMLElement): void {\n        try {\n            // Clear container\n            container.innerHTML = '';\n\n            // Create and append element\n            const element = createDOMElement(vnode);\n            container.appendChild(element);\n\n        } catch (error) {\n            handleError(error as Error, vnode, 'render');\n        }\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/patch.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode, VNodeChild } from '../types';\n    import { isNullOrBoolean, isPrimitive, getChildAt } from '../utils/helpers';\n    import { handleError } from '../utils/errors';\n    import { createDOMElement } from './render';\n    import { updateProps } from './props';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ HELPER FUNCTIONS (DEFINED FIRST) ════════════╗\n\n    /**\n     * Patch a single child\n     */\n    function patchChild(\n        parent: HTMLElement,\n        oldChild: VNodeChild,\n        newChild: VNodeChild,\n        index: number\n    ): void {\n        // Skip null/boolean children\n        if (isNullOrBoolean(newChild)) {\n            if (!isNullOrBoolean(oldChild)) {\n                const node = parent.childNodes[index];\n                if (node) parent.removeChild(node);\n            }\n            return;\n        }\n\n        // Convert to proper types for patch function\n        const oldVNode = isNullOrBoolean(oldChild) ? null : oldChild;\n        patch(parent, oldVNode as any, newChild as any, index);\n    }\n\n    /**\n     * Patch children by index (simple diffing without keys)\n     */\n    function patchChildrenByIndex(\n        parent: HTMLElement,\n        oldChildren: VNodeChild[],\n        newChildren: VNodeChild[]\n    ): void {\n        const maxLength = Math.max(oldChildren.length, newChildren.length);\n\n        // Patch each child\n        for (let i = 0; i < maxLength; i++) {\n            patchChild(parent, oldChildren[i], newChildren[i], i);\n        }\n\n        // Remove excess children\n        while (parent.childNodes.length > newChildren.filter(c => !isNullOrBoolean(c)).length) {\n            const lastChild = parent.lastChild;\n            if (lastChild) parent.removeChild(lastChild);\n        }\n    }\n\n    /**\n     * Patch children with keys (optimized diffing)\n     * Properly map VNode children to DOM elements\n     */\n    function patchChildrenWithKeys(\n        parent: HTMLElement,\n        oldChildren: VNodeChild[],\n        newChildren: VNodeChild[]\n    ): void {\n        // Step 1: Build map of old keyed elements\n        // CRITICAL FIX: Only use ELEMENT nodes, not all childNodes\n        const oldKeyMap = new Map<any, { vnode: VNode; element: HTMLElement }>();\n\n        // Get only element children (skip text nodes)\n        const domElements: HTMLElement[] = [];\n        for (let i = 0; i < parent.children.length; i++) {\n            domElements.push(parent.children[i] as HTMLElement);\n        }\n\n        // Match VNode children with DOM elements\n        let elementIndex = 0;\n        for (const child of oldChildren) {\n            if (isNullOrBoolean(child)) continue;\n            if (isPrimitive(child)) continue; // Skip text nodes in VNode children\n\n            const vnode = child as VNode;\n            const element = domElements[elementIndex];\n\n            if (!element) break;\n\n            if (vnode.props.key != null) {\n                const key = vnode.props.key;\n                oldKeyMap.set(key, { vnode, element });\n            }\n            elementIndex++;\n        }\n\n        // Step 2: Build the new DOM structure\n        const newElements: Node[] = [];\n\n        for (let i = 0; i < newChildren.length; i++) {\n            const newChild = newChildren[i];\n            if (isNullOrBoolean(newChild)) continue;\n\n            // Handle text nodes\n            if (isPrimitive(newChild)) {\n                const textNode = document.createTextNode(String(newChild));\n                newElements.push(textNode);\n                continue;\n            }\n\n            const newVNode = newChild as VNode;\n            const key = newVNode.props.key;\n\n            // Try to reuse existing keyed element\n            if (key != null && oldKeyMap.has(key)) {\n                const { vnode: oldVNode, element } = oldKeyMap.get(key)!;\n\n                // Update the existing element\n                updateProps(element, oldVNode.props, newVNode.props);\n\n                // Recursively patch children\n                const oldChildrenArray = oldVNode.children || [];\n                const newChildrenArray = newVNode.children || [];\n\n                const childrenHaveKeys = newChildrenArray.some(\n                    c => c && typeof c === 'object' && 'props' in c && c.props.key != null\n                );\n\n                if (childrenHaveKeys) {\n                    patchChildrenWithKeys(element, oldChildrenArray, newChildrenArray);\n                } else {\n                    patchChildrenByIndex(element, oldChildrenArray, newChildrenArray);\n                }\n\n                newElements.push(element);\n                // Mark as used by deleting from map\n                oldKeyMap.delete(key);\n            } else {\n                // Create new element\n                const newElement = createDOMElement(newVNode);\n                newElements.push(newElement);\n            }\n        }\n\n        // Step 3: Update the DOM to match the new order\n        // Remove all children first\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n\n        // Append in the correct order\n        for (let i = 0; i < newElements.length; i++) {\n            const element = newElements[i];\n            parent.appendChild(element);\n        }\n    }\n\n    /**\n     * Patch children - decides between keyed and simple patching\n     */\n    function patchChildren(\n        parent: HTMLElement,\n        oldChildren: VNodeChild[],\n        newChildren: VNodeChild[]\n    ): void {\n        // Check if we should use keyed diffing\n        const hasKeys = newChildren.some(child =>\n            child && typeof child === 'object' && 'props' in child && child.props.key != null\n        );\n\n        if (hasKeys) {\n            patchChildrenWithKeys(parent, oldChildren, newChildren);\n        } else {\n            patchChildrenByIndex(parent, oldChildren, newChildren);\n        }\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ MAIN PATCH FUNCTIONS ════════════════════════╗\n\n    /**\n     * Add a new node to parent\n     */\n    function addNode(parent: HTMLElement, vnode: VNode | string | number): void {\n        const element = createDOMElement(vnode as any);\n        parent.appendChild(element);\n    }\n\n    /**\n     * Remove a node from parent\n     */\n    function removeNode(parent: HTMLElement, node: Node | undefined): void {\n        if (node && node.parentNode === parent) {\n            parent.removeChild(node);\n        }\n    }\n\n    /**\n     * Update text node\n     */\n    function updateTextNode(\n        parent: HTMLElement,\n        oldText: string | number,\n        newText: string | number,\n        index: number,\n        oldChild: Node | undefined\n    ): void {\n        const oldStr = String(oldText);\n        const newStr = String(newText);\n\n        if (oldStr === newStr) return;\n\n        if (oldChild?.nodeType === Node.TEXT_NODE) {\n            oldChild.textContent = newStr;\n        } else {\n            const textNode = document.createTextNode(newStr);\n            if (oldChild) {\n                parent.replaceChild(textNode, oldChild);\n            } else {\n                parent.appendChild(textNode);\n            }\n        }\n    }\n\n    /**\n     * Replace node completely\n     */\n    function replaceNode(\n        parent: HTMLElement,\n        newVNode: VNode | string | number,\n        oldChild: Node | undefined\n    ): void {\n        const newElement = createDOMElement(newVNode as any);\n\n        if (oldChild) {\n            parent.replaceChild(newElement, oldChild);\n        } else {\n            parent.appendChild(newElement);\n        }\n    }\n\n    /**\n     * Check if VNode has changed (needs replacement)\n     */\n    function hasVNodeChanged(oldVNode: VNode, newVNode: VNode): boolean {\n        return (\n            oldVNode.type !== newVNode.type ||\n            oldVNode.props.key !== newVNode.props.key\n        );\n    }\n\n    /**\n     * Update element in place\n     * FIXED: Detect if we're patching the parent element itself vs its children\n     */\n    function updateElement(\n        parent: HTMLElement,\n        oldVNode: VNode,\n        newVNode: VNode,\n        index: number,\n        oldChild: Node | undefined\n    ): void {\n        let elementToUpdate: HTMLElement;\n\n        // CRITICAL: Check if we're patching the parent element itself\n        // This happens when parent's tag matches BOTH VNode types\n        // AND the oldChild either doesn't exist OR has a different tag than the VNode\n        // This pattern: patch(ul, ulVNode, ulVNode, 0) where we want to update ul's children\n        const parentMatchesVNode = parent.tagName.toLowerCase() === oldVNode.type &&\n                                   parent.tagName.toLowerCase() === newVNode.type;\n        const childIsDifferentType = oldChild instanceof HTMLElement &&\n                                    oldChild.tagName.toLowerCase() !== oldVNode.type;\n\n        if (parentMatchesVNode && (!oldChild || childIsDifferentType)) {\n            // We're updating the parent element itself, not a child\n            elementToUpdate = parent;\n        } else if (oldChild instanceof HTMLElement) {\n            // We're updating a child element\n            elementToUpdate = oldChild;\n        } else {\n            // Fallback: replace the node\n            replaceNode(parent, newVNode, oldChild);\n            return;\n        }\n\n        // Update props\n        updateProps(elementToUpdate, oldVNode.props, newVNode.props);\n\n        // Update children\n        const oldChildren = oldVNode.children || [];\n        const newChildren = newVNode.children || [];\n\n        patchChildren(elementToUpdate, oldChildren, newChildren);\n    }\n\n    /**\n     * Update existing node or replace if needed\n     */\n    function updateNode(\n        parent: HTMLElement,\n        oldVNode: VNode | string | number,\n        newVNode: VNode | string | number,\n        index: number,\n        oldChild: Node | undefined\n    ): void {\n        // Both are primitives (text nodes)\n        if (isPrimitive(oldVNode) && isPrimitive(newVNode)) {\n            updateTextNode(parent, oldVNode, newVNode, index, oldChild);\n            return;\n        }\n\n        // Type changed or one is primitive - replace completely\n        if (\n            (isPrimitive(oldVNode) && !isPrimitive(newVNode)) ||\n            (!isPrimitive(oldVNode) && isPrimitive(newVNode)) ||\n            hasVNodeChanged(oldVNode as VNode, newVNode as VNode)\n        ) {\n            replaceNode(parent, newVNode, oldChild);\n            return;\n        }\n\n        // Both are VNodes of same type - update in place\n        if (!isPrimitive(oldVNode) && !isPrimitive(newVNode)) {\n            updateElement(parent, oldVNode as VNode, newVNode as VNode, index, oldChild);\n        }\n    }\n\n    /**\n     * Patch/diff algorithm - updates DOM based on VNode changes\n     *\n     * @param parent - Parent HTML element\n     * @param oldVNode - Old virtual node\n     * @param newVNode - New virtual node\n     * @param index - Child index in parent\n     */\n    export function patch(\n        parent: HTMLElement,\n        oldVNode: VNode | string | number | null,\n        newVNode: VNode | string | number | null,\n        index: number = 0\n    ): void {\n        try {\n            const oldChild = getChildAt(parent, index);\n\n            // Case 1: Add new node\n            if (!oldVNode && newVNode) {\n                addNode(parent, newVNode);\n                return;\n            }\n\n            // Case 2: Remove old node\n            if (oldVNode && !newVNode) {\n                removeNode(parent, oldChild);\n                return;\n            }\n\n            // Case 3: Both exist - update or replace\n            if (oldVNode && newVNode) {\n                updateNode(parent, oldVNode, newVNode, index, oldChild);\n            }\n\n        } catch (error) {\n            handleError(\n                error as Error,\n                typeof newVNode === 'object' && newVNode !== null ? newVNode : undefined,\n                'patch'\n            );\n        }\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝"]}