{"version":3,"sources":["../src/utils/helpers.ts","../src/utils/errors.ts","../src/core/createElement.ts","../src/core/html.ts","../src/core/props.ts","../src/core/render.ts","../src/core/patch.ts"],"names":["isNullOrBoolean","value","isVNode","isPrimitive","flattenChildren","children","flattened","child","sanitizeHTML","html","dangerous","sanitized","pattern","camelToKebab","str","shallowEqual","a","b","keysA","keysB","key","idCounter","generateId","prefix","isBrowser","getChildAt","parent","index","isFunction","isEventProp","propName","getEventName","deepClone","obj","cloned","config","setConfig","newConfig","getConfig","VDOMError","message","vnode","context","handleError","error","vdomError","handlerError","warn","assert","condition","createErrorPlaceholder","validateVNode","withErrorHandling","fn","args","createElement","type","props","flatChildren","normalizedProps","Fragment","createTextNode","text","h","div","span","h1","h2","h3","h4","h5","h6","p","i","img","jsx","jsxs","jsxDEV","MARKERS","strings","values","htmlString","isInAttribute","marker","createMarker","parseHTML","applyEventHandlers","handler","lastEqualIndex","lastGtIndex","processedHTML","eventMarkerProtection","protectionIndex","match","eventName","placeholder","original","template","element","result","convertDOMToVNode","handleTextNode","el","parseAttributes","parseChildren","array","item","processedText","attributes","attr","name","replaceMarkers","replaced","childNodes","foundArray","foundVNodes","converted","valueMap","BOOLEAN_ATTRS","updateProps","oldProps","newProps","removeProperty","setProperty","oldValue","setEventListener","setClassName","setStyle","__value","setBooleanAttribute","setAttribute","oldHandler","className","prop","val","attrName","createDOMElement","createFragment","createRegularElement","fragment","childElement","render","container","patchChild","oldChild","newChild","node","oldVNode","patch","patchChildrenByIndex","oldChildren","newChildren","maxLength","_","idx","c","lastChild","patchChildrenWithKeys","oldKeyMap","domElements","elementIndex","newElements","textNode","newVNode","oldChildrenArray","newChildrenArray","newElement","patchChildren","addNode","removeNode","updateTextNode","oldText","newText","oldStr","newStr","replaceNode","hasVNodeChanged","updateElement","elementToUpdate","parentMatchesVNode","childIsDifferentType","updateNode"],"mappings":"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","file":"main.cjs","sourcesContent":["// src/utils/helpers.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNodeChild, VNodeChildren } from '../types';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Check if value should be skipped in rendering\n     */\n    export function isNullOrBoolean(value: unknown): value is false | null | undefined | true {\n        return value === false || value === null || value === undefined || value === true;\n    }\n\n    /**\n     * Check if value is a VNode\n     * FIX: Return false for null instead of null\n     */\n    export function isVNode(value: unknown): boolean {\n        if (!value || typeof value !== 'object') {\n            return false;\n        }\n        return 'type' in value && 'props' in value && 'children' in value;\n    }\n\n    /**\n     * Check if value is a primitive that can be rendered\n     */\n    export function isPrimitive(value: unknown): value is string | number {\n        return typeof value === 'string' || typeof value === 'number';\n    }\n\n    /**\n     * Flatten nested children arrays recursively\n     */\n    export function flattenChildren(children: VNodeChildren[]): VNodeChild[] {\n        const flattened: VNodeChild[] = [];\n\n        for (const child of children) {\n            if (Array.isArray(child)) {\n                flattened.push(...flattenChildren(child));\n            } else if (!isNullOrBoolean(child)) {\n                flattened.push(child);\n            }\n        }\n\n        return flattened;\n    }\n\n    /**\n     * Sanitize HTML to prevent XSS attacks\n     */\n    export function sanitizeHTML(html: string): string {\n        // Remove dangerous patterns\n        const dangerous = [\n            /<script[\\s\\S]*?<\\/script>/gi,\n            /javascript:/gi,\n            /on\\w+\\s*=/gi, // inline event handlers like onerror=\n            /<iframe[\\s\\S]*?<\\/iframe>/gi,\n            /<object[\\s\\S]*?<\\/object>/gi,\n            /<embed[\\s\\S]*?>/gi,\n        ];\n\n        let sanitized = html;\n        for (const pattern of dangerous) {\n            sanitized = sanitized.replace(pattern, '');\n        }\n\n        return sanitized;\n    }\n\n    /**\n     * Convert camelCase to kebab-case\n     */\n    export function camelToKebab(str: string): string {\n        return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n    }\n\n    /**\n     * Check if two values are equal (shallow comparison)\n     */\n    export function shallowEqual(a: unknown, b: unknown): boolean {\n        if (a === b) return true;\n        if (typeof a !== typeof b) return false;\n        if (typeof a !== 'object' || a === null || b === null) return false;\n\n        const keysA = Object.keys(a);\n        const keysB = Object.keys(b as Record<string, unknown>);\n\n        if (keysA.length !== keysB.length) return false;\n\n        for (const key of keysA) {\n            if ((a as Record<string, unknown>)[key] !== (b as Record<string, unknown>)[key]) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Generate unique ID\n     */\n    let idCounter = 0;\n    export function generateId(prefix = 'vdom'): string {\n        return `${prefix}-${++idCounter}-${Date.now()}`;\n    }\n\n    /**\n     * Check if code is running in browser environment\n     */\n    export function isBrowser(): boolean {\n        return typeof window !== 'undefined' && typeof document !== 'undefined';\n    }\n\n    /**\n     * Safe way to get element from parent by index\n     */\n    export function getChildAt(parent: HTMLElement, index: number): Node | undefined {\n        return parent.childNodes[index] as Node | undefined;\n    }\n\n    /**\n     * Check if value is a function\n     */\n    export function isFunction(value: unknown): value is (...args: unknown[]) => unknown {\n        return typeof value === 'function';\n    }\n\n    /**\n     * Check if string is an event handler prop name\n     */\n    export function isEventProp(propName: string): boolean {\n        return propName.startsWith('on') && propName.length > 2;\n    }\n\n    /**\n     * Get event name from prop name (onclick -> click)\n     */\n    export function getEventName(propName: string): string {\n        return propName.substring(2).toLowerCase();\n    }\n\n    /**\n     * Deep clone object (simple implementation)\n     */\n    export function deepClone<T>(obj: T): T {\n        if (obj === null || typeof obj !== 'object') return obj;\n        if (Array.isArray(obj)) return obj.map(deepClone) as T;\n\n        const cloned: Record<string, unknown> = {};\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                cloned[key] = deepClone((obj as Record<string, unknown>)[key]);\n            }\n        }\n        return cloned as T;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/utils/errors.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode, VDOMConfig } from '../types';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Global configuration\n     */\n    let config: VDOMConfig = {\n        devMode: process.env.NODE_ENV !== 'production',\n        sanitizeHTML: true,\n        onError: undefined,\n    };\n\n    /**\n     * Set global configuration\n     */\n    export function setConfig(newConfig: Partial<VDOMConfig>): void {\n        config = { ...config, ...newConfig };\n    }\n\n    /**\n     * Get current configuration\n     */\n    export function getConfig(): VDOMConfig {\n        return { ...config };\n    }\n\n    /**\n     * Custom error class for VDOM errors\n     */\n    export class VDOMError extends Error {\n        constructor(\n            message: string,\n            public vnode?: VNode,\n            public context?: string\n        ) {\n            super(message);\n            this.name = 'VDOMError';\n        }\n    }\n\n    /**\n     * Handle errors with custom error handler if provided\n     */\n    export function handleError(error: Error, vnode?: VNode, context?: string): void {\n        const vdomError = error instanceof VDOMError\n            ? error\n            : new VDOMError(error.message, vnode, context);\n\n        if (config.onError) {\n            try {\n                config.onError(vdomError, vnode);\n            } catch (handlerError) {\n                console.error('Error in custom error handler:', handlerError);\n                console.error('Original error:', vdomError);\n            }\n        } else {\n            console.error('VDOM Error:', vdomError.message);\n            if (config.devMode && vnode) {\n                console.error('VNode:', vnode);\n                if (context) console.error('Context:', context);\n            }\n        }\n    }\n\n    /**\n     * Warning function (only in dev mode)\n     */\n    export function warn(message: string, vnode?: VNode): void {\n        if (config.devMode) {\n            console.warn(`[VDOM Warning]: ${message}`);\n            if (vnode) console.warn('VNode:', vnode);\n        }\n    }\n\n    /**\n     * Assert function for development checks\n     */\n    export function assert(condition: boolean, message: string): void {\n        if (config.devMode && !condition) {\n            throw new VDOMError(`Assertion failed: ${message}`);\n        }\n    }\n\n    /**\n     * Create error placeholder element\n     */\n    export function createErrorPlaceholder(error: Error): Text {\n        const message = config.devMode\n            ? `[Render Error: ${error.message}]`\n            : '[Render Error]';\n        return document.createTextNode(message);\n    }\n\n    /**\n     * Validate VNode structure\n     */\n    export function validateVNode(vnode: unknown): vnode is VNode {\n        if (!vnode || typeof vnode !== 'object') {\n            return false;\n        }\n\n        if (!('type' in vnode && 'props' in vnode && 'children' in vnode)) {\n            if (config.devMode) {\n                warn('Invalid VNode structure: missing required properties (type, props, children)', vnode as VNode);\n            }\n            return false;\n        }\n\n        if (typeof vnode.type !== 'string') {\n            if (config.devMode) {\n                warn('Invalid VNode type: must be a string', vnode as VNode);\n            }\n            return false;\n        }\n\n        if (!Array.isArray(vnode.children)) {\n            if (config.devMode) {\n                warn('Invalid VNode children: must be an array', vnode as VNode);\n            }\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Wrap function with error handling\n     */\n    export function withErrorHandling<TArgs extends unknown[], TReturn>(\n        fn: (...args: TArgs) => TReturn,\n        context?: string\n    ): (...args: TArgs) => TReturn | null {\n        return (...args: TArgs): TReturn | null => {\n            try {\n                return fn(...args);\n            } catch (error) {\n                handleError(error as Error, undefined, context);\n                return null;\n            }\n        };\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/createElement.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode, VNodeProps, VNodeChild, VNodeChildren } from '../types';\n    import { flattenChildren } from '../utils/helpers';\n    import { warn } from '../utils/errors';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Create a Virtual Node\n     *\n     * @param type - Element type or 'fragment'\n     * @param props - Element properties\n     * @param children - Child elements\n     * @returns VNode\n     *\n     * @example\n     * ```ts\n     * const vnode = createElement('div', { className: 'box' }, 'Hello World');\n     * ```\n     */\n    export function createElement(\n        type: string | 'fragment',\n        props: VNodeProps | string | null = null,\n        ...children: VNodeChildren[]\n    ): VNode {\n        // Validate type in development\n        if (process.env.NODE_ENV !== 'production') {\n            if (!type || typeof type !== 'string') {\n                warn(`Invalid element type: ${type}`);\n            }\n        }\n\n        if(typeof props === 'string') {\n            props = { className: props };\n        }\n\n        const flatChildren = flattenChildren(children);\n\n        // Handle fragments\n        if (type === 'fragment') {\n            return {\n                type: 'fragment',\n                props: {},\n                children: flatChildren,\n            };\n        }\n\n        // Handle class vs className\n        const normalizedProps = props ? { ...props } : {};\n        if (normalizedProps.class && !normalizedProps.className) {\n            normalizedProps.className = normalizedProps.class;\n            delete normalizedProps.class;\n        }\n\n        return {\n            type,\n            props: normalizedProps,\n            children: flatChildren,\n        };\n    }\n\n    /**\n     * Create a fragment (wrapper for multiple children without parent element)\n     *\n     * @param children - Child elements\n     * @returns VNode with type 'fragment'\n     *\n     * @example\n     * ```ts\n     * const frag = Fragment(\n     *   createElement('div', {}, 'First'),\n     *   createElement('div', {}, 'Second')\n     * );\n     * ```\n     */\n    export function Fragment(...children: VNodeChild[]): VNode {\n        return createElement('fragment', null, ...children);\n    }\n\n    /**\n     * Create a text node\n     *\n     * @param text - Text content\n     * @returns String that will be rendered as text\n     */\n    export function createTextNode(text: string | number): string {\n        return String(text);\n    }\n\n    /**\n     * JSX Factory function (for JSX pragma)\n     * Alias for createElement to be used with JSX\n     */\n    export const h = createElement;\n    export const div = (props?: VNodeProps | string | null | undefined, ...children: VNodeChildren[]): VNode => {\n        return h('div', props, ...children);\n    };\n    export const span = (props?: VNodeProps | string | null | undefined, ...children: VNodeChildren[]): VNode => {\n        return h('span', props, ...children);\n    };\n    export const h1 = (props?: VNodeProps | string | null | undefined, ...children: VNodeChildren[]): VNode => {\n        return h('h1', props, ...children);\n    };\n    export const h2 = (props?: VNodeProps | string | null | undefined, ...children: VNodeChildren[]): VNode => {\n        return h('h2', props, ...children);\n    };\n    export const h3 = (props?: VNodeProps | string | null | undefined, ...children: VNodeChildren[]): VNode => {\n        return h('h3', props, ...children);\n    };\n    export const h4 = (props?: VNodeProps | string | null | undefined, ...children: VNodeChildren[]): VNode => {\n        return h('h4', props, ...children);\n    };\n    export const h5 = (props?: VNodeProps | string | null | undefined, ...children: VNodeChildren[]): VNode => {\n        return h('h5', props, ...children);\n    };\n    export const h6 = (props?: VNodeProps | string | null | undefined, ...children: VNodeChildren[]): VNode => {\n        return h('h6', props, ...children);\n    };\n    export const p = (props?: VNodeProps | string | null | undefined, ...children: VNodeChildren[]): VNode => {\n        return h('p', props, ...children);\n    };\n    export const i = (props?: VNodeProps | string | null | undefined, ...children: VNodeChildren[]): VNode => {\n        return h('i', props, ...children);\n    };\n    export const a = (props?: VNodeProps | string | null | undefined, ...children: VNodeChildren[]): VNode => {\n        return h('a', props, ...children);\n    };\n    export const img = (props?: VNodeProps | string | null | undefined, ...children: VNodeChildren[]): VNode => {\n        return h('img', props, ...children);\n    };\n\n    /**\n     * JSX Fragment factory\n     */\n    export const jsx = createElement;\n    export const jsxs = createElement;\n    export const jsxDEV = createElement;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/html.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode, ParseContext, EventHandler, VNodeChild } from '../types';\n    import { isNullOrBoolean } from '../utils/helpers';\n    import { sanitizeHTML } from '../utils/helpers';\n    import { getConfig } from '../utils/errors';\n    import { createElement } from './createElement';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Markers for identifying interpolated values\n     */\n    const MARKERS = {\n        EVENT: '__EVENT_',\n        VNODE: '__VNODE_',\n        ARRAY: '__ARRAY_',\n        VALUE: '__VALUE_'\n    } as const;\n\n    /**\n     * HTML tagged template literal\n     * Creates VNodes from HTML template strings with interpolated values\n     *\n     * FIX: Store event handlers separately and apply after parsing to avoid HTML parser issues\n     */\n    export function html(\n        strings: TemplateStringsArray,\n        ...values: unknown[]\n    ): VNode {\n        const context: ParseContext = {\n            eventHandlers: new Map(),\n            vnodes: new Map(),\n            arrays: new Map(),\n            plainValues: new Map(),\n        };\n\n        let htmlString = '';\n\n        // Build HTML string and store values\n        for (let i = 0; i < strings.length; i++) {\n            const str = strings[i];\n            htmlString += str;\n\n            if (i < values.length) {\n                const value = values[i];\n\n                if (isNullOrBoolean(value)) {\n                    if (value === false && isInAttribute(str)) {\n                        htmlString += 'false';\n                    }\n                    continue;\n                }\n\n                const marker = createMarker(value, i, context);\n                htmlString += marker;\n            }\n        }\n\n        const vnode = parseHTML(htmlString, context);\n\n        // Apply event handlers from context to the VNode\n        applyEventHandlers(vnode, context);\n\n        return vnode;\n    }\n\n    /**\n     * Apply stored event handlers to VNode props\n     * Recursively searches for event handler markers and replaces them with actual functions\n     */\n    function applyEventHandlers(vnode: VNode, context: ParseContext): void {\n        // Check props for event handler markers and replace them\n        for (const [key, value] of Object.entries(vnode.props)) {\n            if (key.startsWith('on') && typeof value === 'string') {\n                // The value should be the event marker like \"__EVENT_0__\"\n                // Try exact match first\n                if (context.eventHandlers.has(value)) {\n                    vnode.props[key] = context.eventHandlers.get(value);\n                    continue;\n                }\n\n                // If not exact match, try finding any marker that's contained in the value\n                for (const [marker, handler] of context.eventHandlers) {\n                    if (value.includes(marker)) {\n                        vnode.props[key] = handler;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Recursively apply to children\n        for (const child of vnode.children) {\n            if (child && typeof child === 'object' && 'type' in child) {\n                applyEventHandlers(child as VNode, context);\n            }\n        }\n    }\n\n    /**\n     * Check if we're currently inside an attribute VALUE (not name)\n     */\n    function isInAttribute(str: string): boolean {\n        const lastEqualIndex = str.lastIndexOf('=');\n        const lastGtIndex = str.lastIndexOf('>');\n        return lastEqualIndex > lastGtIndex;\n    }\n\n    /**\n     * Create appropriate marker for value type\n     */\n    function createMarker(value: unknown, index: number, context: ParseContext): string {\n        // Arrays\n        if (Array.isArray(value)) {\n            const marker = `${MARKERS.ARRAY}${index}__`;\n            context.arrays.set(marker, value);\n            return marker;\n        }\n\n        // Functions (event handlers)\n        if (typeof value === 'function') {\n            const marker = `${MARKERS.EVENT}${index}__`;\n            context.eventHandlers.set(marker, value as EventHandler);\n            return marker;\n        }\n\n        // VNodes\n        if (value && typeof value === 'object' && 'type' in value) {\n            const marker = `${MARKERS.VNODE}${index}__`;\n            context.vnodes.set(marker, value as VNode);\n            return marker;\n        }\n\n        // Plain values\n        const marker = `${MARKERS.VALUE}${index}__`;\n        context.plainValues.set(marker, value);\n        return marker;\n    }\n\n    /**\n     * Parse HTML string to VNode\n     */\n    function parseHTML(html: string, context: ParseContext): VNode {\n        const config = getConfig();\n\n        let processedHTML = html.trim();\n\n        if (config.sanitizeHTML) {\n            // CRITICAL FIX: Protect event markers BEFORE sanitization\n            // The sanitizer removes onclick=\"...\" attributes, so we need to protect our markers\n            const eventMarkerProtection: { placeholder: string; original: string }[] = [];\n            let protectionIndex = 0;\n\n            // Replace onclick=\"__EVENT_N__\" with a safe placeholder\n            processedHTML = processedHTML.replace(/\\s+(on\\w+)=\"(__EVENT_\\d+__)\"/g, (match, eventName, marker) => {\n                const placeholder = `data-vdom-event-${protectionIndex}=\"${marker}\"`;\n                eventMarkerProtection.push({ placeholder, original: match });\n                protectionIndex++;\n                return ` ${placeholder}`;\n            });\n\n            // Also handle onclick=__EVENT_N__ (without quotes)\n            processedHTML = processedHTML.replace(/\\s+(on\\w+)=(__EVENT_\\d+__)/g, (match, eventName, marker) => {\n                const placeholder = `data-vdom-event-${protectionIndex}=\"${marker}\"`;\n                eventMarkerProtection.push({ placeholder, original: match });\n                protectionIndex++;\n                return ` ${placeholder}`;\n            });\n\n            // Now sanitize\n            processedHTML = sanitizeHTML(processedHTML);\n\n            // Restore event markers\n            for (const { placeholder, original } of eventMarkerProtection) {\n                processedHTML = processedHTML.replace(placeholder, original);\n            }\n        }\n\n        const template = document.createElement('template');\n        template.innerHTML = processedHTML;\n\n        const element = template.content.firstChild as HTMLElement;\n\n        if (!element) {\n            return createElement('div', {}, '');\n        }\n\n        const result = convertDOMToVNode(element, context);\n\n        // If result is a string (text node), wrap it in a span\n        if (typeof result === 'string') {\n            return createElement('span', {}, result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Convert DOM node to VNode\n     */\n    function convertDOMToVNode(element: Node, context: ParseContext): VNode | string {\n        // Text nodes\n        if (element.nodeType === Node.TEXT_NODE) {\n            return handleTextNode(element.textContent || '', context);\n        }\n\n        // Skip non-element nodes\n        if (element.nodeType !== Node.ELEMENT_NODE) {\n            return '';\n        }\n\n        const el = element as HTMLElement;\n        const props = parseAttributes(el.attributes, context);\n        const children = parseChildren(el.childNodes, context) as VNodeChild[];\n\n        return {\n            type: el.tagName.toLowerCase(),\n            props,\n            children,\n        };\n    }\n\n    /**\n     * Handle text node with markers\n     */\n    function handleTextNode(text: string, context: ParseContext): VNode | string {\n        // Check for array markers\n        for (const [marker, array] of context.arrays) {\n            if (text.includes(marker)) {\n                return {\n                    type: 'fragment',\n                    props: {},\n                    children: array.filter(item => !isNullOrBoolean(item)) as VNodeChild[],\n                };\n            }\n        }\n\n        // Check for VNode markers\n        for (const [marker, vnode] of context.vnodes) {\n            if (text.includes(marker)) {\n                return vnode;\n            }\n        }\n\n        // Replace value markers\n        let processedText = text;\n        for (const [marker, value] of context.plainValues) {\n            processedText = processedText.replace(marker, String(value));\n        }\n\n        return processedText;\n    }\n\n    /**\n     * Parse element attributes\n     * IMPORTANT: Just store the raw marker values for event handlers\n     * We'll replace them with actual functions in applyEventHandlers\n     */\n    function parseAttributes(\n        attributes: NamedNodeMap,\n        context: ParseContext\n    ): Record<string, unknown> {\n        const props: Record<string, unknown> = {};\n\n        for (const attr of Array.from(attributes)) {\n            const { name, value } = attr;\n\n            // Event handlers - keep the marker string as-is\n            // It will be replaced by applyEventHandlers later\n            if (name.startsWith('on')) {\n                props[name] = value;\n                continue;\n            }\n\n            // Class names\n            if (name === 'class') {\n                props.className = replaceMarkers(value, context.plainValues).trim();\n                continue;\n            }\n\n            // Boolean attributes\n            if (name === 'checked' || name === 'disabled' || name === 'selected' || name === 'required') {\n                const replaced = replaceMarkers(value, context.plainValues);\n\n                if (replaced === 'false') {\n                    continue;\n                } else if (replaced === 'true' || replaced === '') {\n                    props[name] = true;\n                } else {\n                    props[name] = replaced;\n                }\n                continue;\n            }\n\n            // Regular attributes\n            props[name] = replaceMarkers(value, context.plainValues);\n        }\n\n        return props;\n    }\n\n    /**\n     * Parse child nodes\n     */\n    function parseChildren(childNodes: NodeListOf<ChildNode>, context: ParseContext): unknown[] {\n        const children: unknown[] = [];\n\n        for (const child of Array.from(childNodes)) {\n            if (child.nodeType === Node.TEXT_NODE) {\n                const text = child.textContent || '';\n\n                // Check for array markers\n                let foundArray = false;\n                for (const [marker, array] of context.arrays) {\n                    if (text.includes(marker)) {\n                        children.push(...array.filter(item => !isNullOrBoolean(item)));\n                        foundArray = true;\n                        break;\n                    }\n                }\n                if (foundArray) continue;\n\n                // Check for VNode markers\n                const foundVNodes: unknown[] = [];\n                for (const [marker, vnode] of context.vnodes) {\n                    if (text.includes(marker)) {\n                        if (vnode && typeof vnode === 'object' && 'type' in vnode) {\n                            foundVNodes.push(vnode);\n                        }\n                    }\n                }\n                if (foundVNodes.length > 0) {\n                    children.push(...foundVNodes);\n                    continue;\n                }\n\n                // Add processed text\n                if (text.trim()) {\n                    const processedText = replaceMarkers(text, context.plainValues);\n                    if (processedText.trim()) {\n                        children.push(processedText);\n                    }\n                }\n            } else if (child.nodeType === Node.ELEMENT_NODE) {\n                const converted = convertDOMToVNode(child, context);\n                if (converted) children.push(converted);\n            }\n        }\n\n        return children;\n    }\n\n    /**\n     * Replace markers in string with actual values\n     */\n    function replaceMarkers(str: string, valueMap: Map<string, unknown>): string {\n        let result = str;\n        for (const [marker, value] of valueMap) {\n            result = result.replace(marker, String(value));\n        }\n        return result;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/props.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNodeProps, StyleObject } from '../types';\n    import { isEventProp, getEventName, isFunction } from '../utils/helpers';\n    import { warn } from '../utils/errors';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Boolean attributes that work differently\n     */\n    const BOOLEAN_ATTRS = new Set([\n        'checked',\n        'selected',\n        'disabled',\n        'readOnly',\n        'required',\n        'autoFocus',\n        'multiple',\n        'hidden',\n        'autoplay',\n        'controls',\n        'loop',\n        'muted',\n        'open',\n        'reversed'\n    ]);\n\n    /**\n     * Update element properties\n     */\n    export function updateProps(\n        element: HTMLElement,\n        oldProps: VNodeProps,\n        newProps: VNodeProps\n    ): void {\n        // Remove old props\n        for (const key in oldProps) {\n            if (!(key in newProps)) {\n                removeProperty(element, key, oldProps[key]);\n            }\n        }\n\n        // Set new props\n        for (const [key, value] of Object.entries(newProps)) {\n            if (oldProps[key] !== value) {\n                setProperty(element, key, value, oldProps[key]);\n            }\n        }\n    }\n\n    /**\n     * Set a single property on element\n     */\n    export function setProperty(\n        element: HTMLElement,\n        key: string,\n        value: unknown,\n        oldValue?: unknown\n    ): void {\n        // Skip special keys\n        if (key === 'children' || key === 'key') return;\n\n        // Event handlers\n        if (isEventProp(key)) {\n            setEventListener(element, key, value, oldValue);\n            return;\n        }\n\n        // Ref callback\n        if (key === 'ref' && isFunction(value)) {\n            value(element);\n            return;\n        }\n\n        // Class name\n        if (key === 'className' || key === 'class') {\n            setClassName(element, value);\n            return;\n        }\n\n        // Style\n        if (key === 'style') {\n            setStyle(element, value as StyleObject | null | undefined);\n            return;\n        }\n\n        // Dangerous HTML\n        const __value = value as { __html: string } | undefined;\n        if (key === 'dangerouslySetInnerHTML' && __value?.__html) {\n            element.innerHTML = __value?.__html;\n            return;\n        }\n\n        // Boolean attributes\n        if (BOOLEAN_ATTRS.has(key)) {\n            setBooleanAttribute(element, key, value);\n            return;\n        }\n\n        // Regular attributes\n        setAttribute(element, key, value);\n    }\n\n    /**\n     * Remove a property from element\n     */\n    export function removeProperty(element: HTMLElement, key: string, oldValue: unknown): void {\n        // Event handlers\n        if (isEventProp(key) && isFunction(oldValue)) {\n            const eventName = getEventName(key);\n            element.removeEventListener(eventName, oldValue as EventListenerOrEventListenerObject);\n            return;\n        }\n\n        // Ref\n        if (key === 'ref' && isFunction(oldValue)) {\n            oldValue(null);\n            return;\n        }\n\n        // Class name\n        if (key === 'className' || key === 'class') {\n            element.className = '';\n            element.removeAttribute('class');\n            return;\n        }\n\n        // Style\n        if (key === 'style') {\n            element.removeAttribute('style');\n            return;\n        }\n\n        // Boolean attributes\n        if (BOOLEAN_ATTRS.has(key)) {\n            element.removeAttribute(key.toLowerCase());\n            return;\n        }\n\n        // Regular attributes\n        element.removeAttribute(key);\n    }\n\n    /**\n     * Set event listener\n     */\n    function setEventListener(\n        element: HTMLElement,\n        propName: string,\n        handler: unknown,\n        oldHandler?: unknown\n    ): void {\n        if (!isFunction(handler)) {\n            if (process.env.NODE_ENV !== 'production') {\n                warn(`Event handler ${propName} is not a function`);\n            }\n            return;\n        }\n\n        const eventName = getEventName(propName);\n\n        // Remove old handler\n        if (oldHandler && isFunction(oldHandler)) {\n            element.removeEventListener(eventName, oldHandler as EventListenerOrEventListenerObject);\n        }\n\n        // Add new handler\n        element.addEventListener(eventName, handler as EventListenerOrEventListenerObject);\n    }\n\n    /**\n     * Set class name\n     */\n    function setClassName(element: HTMLElement, value: unknown): void {\n        if (value == null || value === false) {\n            element.className = '';\n            element.removeAttribute('class');\n            return;\n        }\n\n        const className = String(value).trim();\n        if (className) {\n            element.className = className;\n        } else {\n            element.className = '';\n            element.removeAttribute('class');\n        }\n    }\n\n    type SetStyleValueType = string | StyleObject | null | undefined;\n    /**\n     * Set style attribute\n     */\n    function setStyle(element: HTMLElement, value: SetStyleValueType): void {\n        if (value == null) {\n            element.removeAttribute('style');\n            return;\n        }\n\n        // String style\n        if (typeof value === 'string') {\n            element.setAttribute('style', value);\n            return;\n        }\n\n        // Object style\n        if (typeof value === 'object') {\n            for (const [prop, val] of Object.entries(value)) {\n                if (val == null) {\n                    (element.style as StyleObject)[prop] = '';\n                } else {\n                    (element.style as StyleObject)[prop] = val as string;\n                }\n            }\n        }\n    }\n\n    /**\n     * Set boolean attribute\n     *\n     * FIXED: Treat any value except false, null, undefined as true\n     * This matches HTML spec and common framework behavior\n     * Special case: empty string '' is valid and sets the attribute\n     */\n    function setBooleanAttribute(element: HTMLElement, key: string, value: unknown): void {\n        const attrName = key.toLowerCase();\n\n        // Explicitly false, null, or undefined removes the attribute\n        if (value === false || value === null || value === undefined) {\n            element.removeAttribute(attrName);\n            return;\n        }\n\n        // Any other value (including empty string '') sets the attribute\n        // This includes: true, 'true', '', 'yes', 'disabled', numbers, etc.\n        element.setAttribute(attrName, '');\n    }\n\n    /**\n     * Set regular attribute\n     */\n    function setAttribute(element: HTMLElement, key: string, value: unknown): void {\n        if (value == null || value === false) {\n            element.removeAttribute(key);\n            return;\n        }\n\n        // Convert to string and set\n        element.setAttribute(key, String(value));\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/render.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode } from '../types';\n    import { isNullOrBoolean, isPrimitive } from '../utils/helpers';\n    import { handleError, createErrorPlaceholder, validateVNode } from '../utils/errors';\n    import { updateProps } from './props';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Create a real DOM element from a VNode\n     *\n     * @param vnode - Virtual node to convert\n     * @returns HTML element, text node, or document fragment\n     */\n    export function createDOMElement(vnode: VNode | string | number): HTMLElement | Text | DocumentFragment {\n        try {\n            // Handle text nodes (primitives)\n            if (isPrimitive(vnode)) {\n                return document.createTextNode(String(vnode));\n            }\n\n            // Validate VNode structure\n            if (!validateVNode(vnode)) {\n                throw new Error('Invalid VNode structure');\n            }\n\n            // Handle fragments\n            if (vnode.type === 'fragment') {\n                return createFragment(vnode);\n            }\n\n            // Handle regular elements\n            return createRegularElement(vnode);\n\n        } catch (error) {\n            handleError(error as Error, typeof vnode === 'object' ? vnode : undefined, 'createDOMElement');\n            return createErrorPlaceholder(error as Error);\n        }\n    }\n\n    /**\n     * Create a document fragment from VNode\n     */\n    function createFragment(vnode: VNode): DocumentFragment {\n        const fragment = document.createDocumentFragment();\n\n        for (const child of vnode.children) {\n            if (isNullOrBoolean(child)) continue;\n\n            const childElement = isPrimitive(child)\n                ? document.createTextNode(String(child))\n                : createDOMElement(child as VNode);\n\n            fragment.appendChild(childElement);\n        }\n\n        return fragment;\n    }\n\n    /**\n     * Create a regular HTML element from VNode\n     */\n    function createRegularElement(vnode: VNode): HTMLElement {\n        // Create element\n        const element = document.createElement(vnode.type);\n\n        // Set properties\n        updateProps(element, {}, vnode.props);\n\n        // Append children\n        for (const child of vnode.children) {\n            if (isNullOrBoolean(child)) continue;\n\n            const childElement = isPrimitive(child)\n                ? document.createTextNode(String(child))\n                : createDOMElement(child as VNode);\n\n            element.appendChild(childElement);\n        }\n\n        return element;\n    }\n\n    /**\n     * Main render function - renders VNode to container\n     *\n     * @param vnode - Virtual node to render\n     * @param container - Container element\n     *\n     * @example\n     * ```ts\n     * const app = createElement('div', {}, 'Hello World');\n     * render(app, document.getElementById('root')!);\n     * ```\n     */\n    export function render(vnode: VNode, container: HTMLElement): void {\n        try {\n            // Clear container\n            container.innerHTML = '';\n\n            // Create and append element\n            const element = createDOMElement(vnode);\n            container.appendChild(element);\n\n        } catch (error) {\n            handleError(error as Error, vnode, 'render');\n        }\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/patch.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode, VNodeChild } from '../types';\n    import { isNullOrBoolean, isPrimitive, getChildAt } from '../utils/helpers';\n    import { handleError } from '../utils/errors';\n    import { createDOMElement } from './render';\n    import { updateProps } from './props';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ HELP ════════════════════════════════════════╗\n\n    /**\n     * Patch a single child\n     */\n    function patchChild(\n        parent: HTMLElement,\n        oldChild: VNodeChild,\n        newChild: VNodeChild,\n        index: number\n    ): void {\n        // Skip null/boolean children\n        if (isNullOrBoolean(newChild)) {\n            if (!isNullOrBoolean(oldChild)) {\n                const node = parent.childNodes[index];\n                if (node) parent.removeChild(node);\n            }\n            return;\n        }\n\n        // Convert to proper types for patch function\n        const oldVNode = isNullOrBoolean(oldChild) ? null : oldChild;\n        patch(parent, oldVNode, newChild, index);\n    }\n\n    /**\n     * Patch children by index (simple diffing without keys)\n     */\n    export function patchChildrenByIndex(\n        parent: HTMLElement,\n        oldChildren: VNodeChild[],\n        newChildren: VNodeChild[]\n    ): void {\n        const maxLength = Math.max(oldChildren.length, newChildren.length);\n\n        // Patch each child\n        for (const i of Array.from({ length: maxLength }, (_, idx) => idx)) {\n            patchChild(parent, oldChildren[i], newChildren[i], i);\n        }\n\n        // Remove excess children\n        while (parent.childNodes.length > newChildren.filter(c => !isNullOrBoolean(c)).length) {\n            const lastChild = parent.lastChild;\n            if (lastChild) parent.removeChild(lastChild);\n        }\n    }\n\n    /**\n     * Patch children with keys (optimized diffing)\n     * Properly map VNode children to DOM elements\n     */\n    export function patchChildrenWithKeys(\n        parent: HTMLElement,\n        oldChildren: VNodeChild[],\n        newChildren: VNodeChild[]\n    ): void {\n        // Step 1: Build map of old keyed elements\n        // CRITICAL FIX: Only use ELEMENT nodes, not all childNodes\n        const oldKeyMap = new Map<unknown, { vnode: VNode; element: HTMLElement }>();\n\n        // Get only element children (skip text nodes)\n        const domElements: HTMLElement[] = [];\n        for (const child of Array.from(parent.children)) {\n            domElements.push(child as HTMLElement);\n        }\n\n        // Match VNode children with DOM elements\n        let elementIndex = 0;\n        for (const child of oldChildren) {\n            if (isNullOrBoolean(child)) continue;\n            if (isPrimitive(child)) continue; // Skip text nodes in VNode children\n\n            const vnode = child as VNode;\n            const element = domElements[elementIndex];\n\n            if (!element) break;\n\n            if (vnode.props.key != null) {\n                const key = vnode.props.key;\n                oldKeyMap.set(key, { vnode, element });\n            }\n            elementIndex++;\n        }\n\n        // Step 2: Build the new DOM structure\n        const newElements: Node[] = [];\n\n        for (const newChild of newChildren) {\n            if (isNullOrBoolean(newChild)) continue;\n\n            // Handle text nodes\n            if (isPrimitive(newChild)) {\n                const textNode = document.createTextNode(String(newChild));\n                newElements.push(textNode);\n                continue;\n            }\n\n            const newVNode = newChild as VNode;\n            const key = newVNode.props.key;\n\n            // Try to reuse existing keyed element\n            if (key != null && oldKeyMap.has(key)) {\n                const { vnode: oldVNode, element } = oldKeyMap.get(key)!;\n\n                // Update the existing element\n                updateProps(element, oldVNode.props, newVNode.props);\n\n                // Recursively patch children\n                const oldChildrenArray = oldVNode.children || [];\n                const newChildrenArray = newVNode.children || [];\n\n                const childrenHaveKeys = newChildrenArray.some(\n                    c => c && typeof c === 'object' && 'props' in c && c.props.key != null\n                );\n\n                if (childrenHaveKeys) {\n                    patchChildrenWithKeys(element, oldChildrenArray, newChildrenArray);\n                } else {\n                    patchChildrenByIndex(element, oldChildrenArray, newChildrenArray);\n                }\n\n                newElements.push(element);\n                // Mark as used by deleting from map\n                oldKeyMap.delete(key);\n            } else {\n                // Create new element\n                const newElement = createDOMElement(newVNode);\n                newElements.push(newElement);\n            }\n        }\n\n        // Step 3: Update the DOM to match the new order\n        // Remove all children first\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n\n        // Append in the correct order\n        for (const element of newElements) {\n            parent.appendChild(element);\n        }\n    }\n\n    /**\n     * Patch children - decides between keyed and simple patching\n     */\n    export function patchChildren(\n        parent: HTMLElement,\n        oldChildren: VNodeChild[],\n        newChildren: VNodeChild[]\n    ): void {\n        // Check if we should use keyed diffing\n        const hasKeys = newChildren.some(child =>\n            child && typeof child === 'object' && 'props' in child && child.props.key != null\n        );\n\n        if (hasKeys) {\n            patchChildrenWithKeys(parent, oldChildren, newChildren);\n        } else {\n            patchChildrenByIndex(parent, oldChildren, newChildren);\n        }\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Add a new node to parent\n     */\n    function addNode(parent: HTMLElement, vnode: VNode | string | number): void {\n        const element = createDOMElement(vnode);\n        parent.appendChild(element);\n    }\n\n    /**\n     * Remove a node from parent\n     */\n    function removeNode(parent: HTMLElement, node: Node | undefined): void {\n        if (node && node.parentNode === parent) {\n            parent.removeChild(node);\n        }\n    }\n\n    /**\n     * Update text node\n     */\n    function updateTextNode(\n        parent: HTMLElement,\n        oldText: string | number,\n        newText: string | number,\n        index: number,\n        oldChild: Node | undefined\n    ): void {\n        const oldStr = String(oldText);\n        const newStr = String(newText);\n\n        if (oldStr === newStr) return;\n\n        if (oldChild?.nodeType === Node.TEXT_NODE) {\n            oldChild.textContent = newStr;\n        } else {\n            const textNode = document.createTextNode(newStr);\n            if (oldChild) {\n                parent.replaceChild(textNode, oldChild);\n            } else {\n                parent.appendChild(textNode);\n            }\n        }\n    }\n\n    /**\n     * Replace node completely\n     */\n    function replaceNode(\n        parent: HTMLElement,\n        newVNode: VNode | string | number,\n        oldChild: Node | undefined\n    ): void {\n        const newElement = createDOMElement(newVNode);\n\n        if (oldChild) {\n            parent.replaceChild(newElement, oldChild);\n        } else {\n            parent.appendChild(newElement);\n        }\n    }\n\n    /**\n     * Check if VNode has changed (needs replacement)\n     */\n    function hasVNodeChanged(oldVNode: VNode, newVNode: VNode): boolean {\n        return (\n            oldVNode.type !== newVNode.type ||\n            oldVNode.props.key !== newVNode.props.key\n        );\n    }\n\n    /**\n     * Update element in place\n     * FIXED: Detect if we're patching the parent element itself vs its children\n     */\n    function updateElement(\n        parent: HTMLElement,\n        oldVNode: VNode,\n        newVNode: VNode,\n        index: number,\n        oldChild: Node | undefined\n    ): void {\n        let elementToUpdate: HTMLElement;\n\n        // CRITICAL: Check if we're patching the parent element itself\n        // This happens when parent's tag matches BOTH VNode types\n        // AND the oldChild either doesn't exist OR has a different tag than the VNode\n        // This pattern: patch(ul, ulVNode, ulVNode, 0) where we want to update ul's children\n        const parentMatchesVNode = parent.tagName.toLowerCase() === oldVNode.type &&\n                                   parent.tagName.toLowerCase() === newVNode.type;\n        const childIsDifferentType = oldChild instanceof HTMLElement &&\n                                    oldChild.tagName.toLowerCase() !== oldVNode.type;\n\n        if (parentMatchesVNode && (!oldChild || childIsDifferentType)) {\n            // We're updating the parent element itself, not a child\n            elementToUpdate = parent;\n        } else if (oldChild instanceof HTMLElement) {\n            // We're updating a child element\n            elementToUpdate = oldChild;\n        } else {\n            // Fallback: replace the node\n            replaceNode(parent, newVNode, oldChild);\n            return;\n        }\n\n        // Update props\n        updateProps(elementToUpdate, oldVNode.props, newVNode.props);\n\n        // Update children\n        const oldChildren = oldVNode.children || [];\n        const newChildren = newVNode.children || [];\n\n        patchChildren(elementToUpdate, oldChildren, newChildren);\n    }\n\n    /**\n     * Update existing node or replace if needed\n     */\n    function updateNode(\n        parent: HTMLElement,\n        oldVNode: VNode | string | number,\n        newVNode: VNode | string | number,\n        index: number,\n        oldChild: Node | undefined\n    ): void {\n        // Both are primitives (text nodes)\n        if (isPrimitive(oldVNode) && isPrimitive(newVNode)) {\n            updateTextNode(parent, oldVNode, newVNode, index, oldChild);\n            return;\n        }\n\n        // Type changed or one is primitive - replace completely\n        if (\n            (isPrimitive(oldVNode) && !isPrimitive(newVNode)) ||\n            (!isPrimitive(oldVNode) && isPrimitive(newVNode)) ||\n            hasVNodeChanged(oldVNode as VNode, newVNode as VNode)\n        ) {\n            replaceNode(parent, newVNode, oldChild);\n            return;\n        }\n\n        // Both are VNodes of same type - update in place\n        if (!isPrimitive(oldVNode) && !isPrimitive(newVNode)) {\n            updateElement(parent, oldVNode as VNode, newVNode as VNode, index, oldChild);\n        }\n    }\n\n    /**\n     * Patch/diff algorithm - updates DOM based on VNode changes\n     *\n     * @param parent - Parent HTML element\n     * @param oldVNode - Old virtual node\n     * @param newVNode - New virtual node\n     * @param index - Child index in parent\n     */\n    export function patch(\n        parent: HTMLElement,\n        oldVNode: VNode | string | number | null,\n        newVNode: VNode | string | number | null,\n        index: number = 0\n    ): void {\n        try {\n            const oldChild = getChildAt(parent, index);\n\n            // Case 1: Add new node\n            if (!oldVNode && newVNode) {\n                addNode(parent, newVNode);\n                return;\n            }\n\n            // Case 2: Remove old node\n            if (oldVNode && !newVNode) {\n                removeNode(parent, oldChild);\n                return;\n            }\n\n            // Case 3: Both exist - update or replace\n            if (oldVNode && newVNode) {\n                updateNode(parent, oldVNode, newVNode, index, oldChild);\n            }\n\n        } catch (error) {\n            handleError(\n                error as Error,\n                typeof newVNode === 'object' && newVNode !== null ? newVNode : undefined,\n                'patch'\n            );\n        }\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n"]}