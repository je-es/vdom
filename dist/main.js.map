{"version":3,"sources":["../src/utils/helpers.ts","../src/utils/errors.ts","../src/core/createElement.ts","../src/core/html.ts","../src/core/props.ts","../src/core/render.ts","../src/core/patch.ts"],"names":["isNullOrBoolean","value","isVNode","isPrimitive","flattenChildren","children","flattened","child","sanitizeHTML","html","dangerous","sanitized","pattern","camelToKebab","str","shallowEqual","a","b","keysA","keysB","key","idCounter","generateId","prefix","isBrowser","getChildAt","parent","index","isFunction","isEventProp","propName","getEventName","deepClone","obj","cloned","config","setConfig","newConfig","getConfig","VDOMError","message","vnode","context","handleError","error","vdomError","handlerError","warn","assert","condition","createErrorPlaceholder","validateVNode","withErrorHandling","fn","args","createElement","type","props","flatChildren","normalizedProps","Fragment","h","jsx","jsxs","jsxDEV","MARKERS","strings","values","htmlString","isInAttribute","marker","createMarker","parseHTML","applyEventHandlers","handler","lastEqualIndex","lastGtIndex","processedHTML","eventMarkerProtection","protectionIndex","match","eventName","placeholder","original","template","element","result","convertDOMToVNode","handleTextNode","el","parseAttributes","parseChildren","text","array","item","processedText","attributes","attr","name","replaceMarkers","replaced","childNodes","foundArray","foundVNodes","converted","valueMap","BOOLEAN_ATTRS","updateProps","oldProps","newProps","removeProperty","setProperty","oldValue","setEventListener","setClassName","setStyle","__value","setBooleanAttribute","setAttribute","oldHandler","className","prop","val","attrName","createDOMElement","createFragment","createRegularElement","fragment","childElement","render","container","patchChild","oldChild","newChild","node","oldVNode","patch","patchChildrenByIndex","oldChildren","newChildren","maxLength","i","_","idx","c","lastChild","patchChildrenWithKeys","oldKeyMap","domElements","elementIndex","newElements","textNode","newVNode","oldChildrenArray","newChildrenArray","newElement","patchChildren","addNode","removeNode","updateTextNode","oldText","newText","oldStr","newStr","replaceNode","hasVNodeChanged","updateElement","elementToUpdate","parentMatchesVNode","childIsDifferentType","updateNode"],"mappings":"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","file":"main.js","sourcesContent":["// src/utils/helpers.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNodeChild, VNodeChildren } from '../types';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Check if value should be skipped in rendering\n     */\n    export function isNullOrBoolean(value: unknown): value is false | null | undefined | true {\n        return value === false || value === null || value === undefined || value === true;\n    }\n\n    /**\n     * Check if value is a VNode\n     * FIX: Return false for null instead of null\n     */\n    export function isVNode(value: unknown): boolean {\n        if (!value || typeof value !== 'object') {\n            return false;\n        }\n        return 'type' in value && 'props' in value && 'children' in value;\n    }\n\n    /**\n     * Check if value is a primitive that can be rendered\n     */\n    export function isPrimitive(value: unknown): value is string | number {\n        return typeof value === 'string' || typeof value === 'number';\n    }\n\n    /**\n     * Flatten nested children arrays recursively\n     */\n    export function flattenChildren(children: VNodeChildren[]): VNodeChild[] {\n        const flattened: VNodeChild[] = [];\n\n        for (const child of children) {\n            if (Array.isArray(child)) {\n                flattened.push(...flattenChildren(child));\n            } else if (!isNullOrBoolean(child)) {\n                flattened.push(child);\n            }\n        }\n\n        return flattened;\n    }\n\n    /**\n     * Sanitize HTML to prevent XSS attacks\n     */\n    export function sanitizeHTML(html: string): string {\n        // Remove dangerous patterns\n        const dangerous = [\n            /<script[\\s\\S]*?<\\/script>/gi,\n            /javascript:/gi,\n            /on\\w+\\s*=/gi, // inline event handlers like onerror=\n            /<iframe[\\s\\S]*?<\\/iframe>/gi,\n            /<object[\\s\\S]*?<\\/object>/gi,\n            /<embed[\\s\\S]*?>/gi,\n        ];\n\n        let sanitized = html;\n        for (const pattern of dangerous) {\n            sanitized = sanitized.replace(pattern, '');\n        }\n\n        return sanitized;\n    }\n\n    /**\n     * Convert camelCase to kebab-case\n     */\n    export function camelToKebab(str: string): string {\n        return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n    }\n\n    /**\n     * Check if two values are equal (shallow comparison)\n     */\n    export function shallowEqual(a: unknown, b: unknown): boolean {\n        if (a === b) return true;\n        if (typeof a !== typeof b) return false;\n        if (typeof a !== 'object' || a === null || b === null) return false;\n\n        const keysA = Object.keys(a);\n        const keysB = Object.keys(b as Record<string, unknown>);\n\n        if (keysA.length !== keysB.length) return false;\n\n        for (const key of keysA) {\n            if ((a as Record<string, unknown>)[key] !== (b as Record<string, unknown>)[key]) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Generate unique ID\n     */\n    let idCounter = 0;\n    export function generateId(prefix = 'vdom'): string {\n        return `${prefix}-${++idCounter}-${Date.now()}`;\n    }\n\n    /**\n     * Check if code is running in browser environment\n     */\n    export function isBrowser(): boolean {\n        return typeof window !== 'undefined' && typeof document !== 'undefined';\n    }\n\n    /**\n     * Safe way to get element from parent by index\n     */\n    export function getChildAt(parent: HTMLElement, index: number): Node | undefined {\n        return parent.childNodes[index] as Node | undefined;\n    }\n\n    /**\n     * Check if value is a function\n     */\n    export function isFunction(value: unknown): value is (...args: unknown[]) => unknown {\n        return typeof value === 'function';\n    }\n\n    /**\n     * Check if string is an event handler prop name\n     */\n    export function isEventProp(propName: string): boolean {\n        return propName.startsWith('on') && propName.length > 2;\n    }\n\n    /**\n     * Get event name from prop name (onclick -> click)\n     */\n    export function getEventName(propName: string): string {\n        return propName.substring(2).toLowerCase();\n    }\n\n    /**\n     * Deep clone object (simple implementation)\n     */\n    export function deepClone<T>(obj: T): T {\n        if (obj === null || typeof obj !== 'object') return obj;\n        if (Array.isArray(obj)) return obj.map(deepClone) as T;\n\n        const cloned: Record<string, unknown> = {};\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                cloned[key] = deepClone((obj as Record<string, unknown>)[key]);\n            }\n        }\n        return cloned as T;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/utils/errors.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode, VDOMConfig } from '../types';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Global configuration\n     */\n    let config: VDOMConfig = {\n        devMode: process.env.NODE_ENV !== 'production',\n        sanitizeHTML: true,\n        onError: undefined,\n    };\n\n    /**\n     * Set global configuration\n     */\n    export function setConfig(newConfig: Partial<VDOMConfig>): void {\n        config = { ...config, ...newConfig };\n    }\n\n    /**\n     * Get current configuration\n     */\n    export function getConfig(): VDOMConfig {\n        return { ...config };\n    }\n\n    /**\n     * Custom error class for VDOM errors\n     */\n    export class VDOMError extends Error {\n        constructor(\n            message: string,\n            public vnode?: VNode,\n            public context?: string\n        ) {\n            super(message);\n            this.name = 'VDOMError';\n        }\n    }\n\n    /**\n     * Handle errors with custom error handler if provided\n     */\n    export function handleError(error: Error, vnode?: VNode, context?: string): void {\n        const vdomError = error instanceof VDOMError\n            ? error\n            : new VDOMError(error.message, vnode, context);\n\n        if (config.onError) {\n            try {\n                config.onError(vdomError, vnode);\n            } catch (handlerError) {\n                console.error('Error in custom error handler:', handlerError);\n                console.error('Original error:', vdomError);\n            }\n        } else {\n            console.error('VDOM Error:', vdomError.message);\n            if (config.devMode && vnode) {\n                console.error('VNode:', vnode);\n                if (context) console.error('Context:', context);\n            }\n        }\n    }\n\n    /**\n     * Warning function (only in dev mode)\n     */\n    export function warn(message: string, vnode?: VNode): void {\n        if (config.devMode) {\n            console.warn(`[VDOM Warning]: ${message}`);\n            if (vnode) console.warn('VNode:', vnode);\n        }\n    }\n\n    /**\n     * Assert function for development checks\n     */\n    export function assert(condition: boolean, message: string): void {\n        if (config.devMode && !condition) {\n            throw new VDOMError(`Assertion failed: ${message}`);\n        }\n    }\n\n    /**\n     * Create error placeholder element\n     */\n    export function createErrorPlaceholder(error: Error): Text {\n        const message = config.devMode\n            ? `[Render Error: ${error.message}]`\n            : '[Render Error]';\n        return document.createTextNode(message);\n    }\n\n    /**\n     * Validate VNode structure\n     */\n    export function validateVNode(vnode: unknown): vnode is VNode {\n        if (!vnode || typeof vnode !== 'object') {\n            return false;\n        }\n\n        if (!('type' in vnode && 'props' in vnode && 'children' in vnode)) {\n            if (config.devMode) {\n                warn('Invalid VNode structure: missing required properties (type, props, children)', vnode as VNode);\n            }\n            return false;\n        }\n\n        if (typeof vnode.type !== 'string') {\n            if (config.devMode) {\n                warn('Invalid VNode type: must be a string', vnode as VNode);\n            }\n            return false;\n        }\n\n        if (!Array.isArray(vnode.children)) {\n            if (config.devMode) {\n                warn('Invalid VNode children: must be an array', vnode as VNode);\n            }\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Wrap function with error handling\n     */\n    export function withErrorHandling<TArgs extends unknown[], TReturn>(\n        fn: (...args: TArgs) => TReturn,\n        context?: string\n    ): (...args: TArgs) => TReturn | null {\n        return (...args: TArgs): TReturn | null => {\n            try {\n                return fn(...args);\n            } catch (error) {\n                handleError(error as Error, undefined, context);\n                return null;\n            }\n        };\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/createElement.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode, VNodeProps, VNodeChild, VNodeChildren } from '../types';\n    import { flattenChildren } from '../utils/helpers';\n    import { warn } from '../utils/errors';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Create a Virtual Node\n     *\n     * @param type - Element type or 'fragment'\n     * @param props - Element properties\n     * @param children - Child elements\n     * @returns VNode\n     *\n     * @example\n     * ```ts\n     * const vnode = createElement('div', { className: 'box' }, 'Hello World');\n     * ```\n     */\n    export function createElement(\n        type: string | 'fragment',\n        props: VNodeProps | null = null,\n        ...children: VNodeChildren[]\n    ): VNode {\n        // Validate type in development\n        if (process.env.NODE_ENV !== 'production') {\n            if (!type || typeof type !== 'string') {\n                warn(`Invalid element type: ${type}`);\n            }\n        }\n\n        const flatChildren = flattenChildren(children);\n\n        // Handle fragments\n        if (type === 'fragment') {\n            return {\n                type: 'fragment',\n                props: {},\n                children: flatChildren,\n            };\n        }\n\n        // Handle class vs className\n        const normalizedProps = props ? { ...props } : {};\n        if (normalizedProps.class && !normalizedProps.className) {\n            normalizedProps.className = normalizedProps.class;\n            delete normalizedProps.class;\n        }\n\n        return {\n            type,\n            props: normalizedProps,\n            children: flatChildren,\n        };\n    }\n\n    /**\n     * Create a fragment (wrapper for multiple children without parent element)\n     *\n     * @param children - Child elements\n     * @returns VNode with type 'fragment'\n     *\n     * @example\n     * ```ts\n     * const frag = Fragment(\n     *   createElement('div', {}, 'First'),\n     *   createElement('div', {}, 'Second')\n     * );\n     * ```\n     */\n    export function Fragment(...children: VNodeChild[]): VNode {\n        return createElement('fragment', null, ...children);\n    }\n\n    /**\n     * Create a text node\n     *\n     * @param text - Text content\n     * @returns String that will be rendered as text\n     */\n    export function createTextNode(text: string | number): string {\n        return String(text);\n    }\n\n    /**\n     * JSX Factory function (for JSX pragma)\n     * Alias for createElement to be used with JSX\n     */\n    export const h = createElement;\n\n    /**\n     * JSX Fragment factory\n     */\n    export const jsx = createElement;\n    export const jsxs = createElement;\n    export const jsxDEV = createElement;\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/html.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode, ParseContext, EventHandler, VNodeChild } from '../types';\n    import { isNullOrBoolean } from '../utils/helpers';\n    import { sanitizeHTML } from '../utils/helpers';\n    import { getConfig } from '../utils/errors';\n    import { createElement } from './createElement';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Markers for identifying interpolated values\n     */\n    const MARKERS = {\n        EVENT: '__EVENT_',\n        VNODE: '__VNODE_',\n        ARRAY: '__ARRAY_',\n        VALUE: '__VALUE_'\n    } as const;\n\n    /**\n     * HTML tagged template literal\n     * Creates VNodes from HTML template strings with interpolated values\n     *\n     * FIX: Store event handlers separately and apply after parsing to avoid HTML parser issues\n     */\n    export function html(\n        strings: TemplateStringsArray,\n        ...values: unknown[]\n    ): VNode {\n        const context: ParseContext = {\n            eventHandlers: new Map(),\n            vnodes: new Map(),\n            arrays: new Map(),\n            plainValues: new Map(),\n        };\n\n        let htmlString = '';\n\n        // Build HTML string and store values\n        for (let i = 0; i < strings.length; i++) {\n            const str = strings[i];\n            htmlString += str;\n\n            if (i < values.length) {\n                const value = values[i];\n\n                if (isNullOrBoolean(value)) {\n                    if (value === false && isInAttribute(str)) {\n                        htmlString += 'false';\n                    }\n                    continue;\n                }\n\n                const marker = createMarker(value, i, context);\n                htmlString += marker;\n            }\n        }\n\n        const vnode = parseHTML(htmlString, context);\n\n        // Apply event handlers from context to the VNode\n        applyEventHandlers(vnode, context);\n\n        return vnode;\n    }\n\n    /**\n     * Apply stored event handlers to VNode props\n     * Recursively searches for event handler markers and replaces them with actual functions\n     */\n    function applyEventHandlers(vnode: VNode, context: ParseContext): void {\n        // Check props for event handler markers and replace them\n        for (const [key, value] of Object.entries(vnode.props)) {\n            if (key.startsWith('on') && typeof value === 'string') {\n                // The value should be the event marker like \"__EVENT_0__\"\n                // Try exact match first\n                if (context.eventHandlers.has(value)) {\n                    vnode.props[key] = context.eventHandlers.get(value);\n                    continue;\n                }\n\n                // If not exact match, try finding any marker that's contained in the value\n                for (const [marker, handler] of context.eventHandlers) {\n                    if (value.includes(marker)) {\n                        vnode.props[key] = handler;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Recursively apply to children\n        for (const child of vnode.children) {\n            if (child && typeof child === 'object' && 'type' in child) {\n                applyEventHandlers(child as VNode, context);\n            }\n        }\n    }\n\n    /**\n     * Check if we're currently inside an attribute VALUE (not name)\n     */\n    function isInAttribute(str: string): boolean {\n        const lastEqualIndex = str.lastIndexOf('=');\n        const lastGtIndex = str.lastIndexOf('>');\n        return lastEqualIndex > lastGtIndex;\n    }\n\n    /**\n     * Create appropriate marker for value type\n     */\n    function createMarker(value: unknown, index: number, context: ParseContext): string {\n        // Arrays\n        if (Array.isArray(value)) {\n            const marker = `${MARKERS.ARRAY}${index}__`;\n            context.arrays.set(marker, value);\n            return marker;\n        }\n\n        // Functions (event handlers)\n        if (typeof value === 'function') {\n            const marker = `${MARKERS.EVENT}${index}__`;\n            context.eventHandlers.set(marker, value as EventHandler);\n            return marker;\n        }\n\n        // VNodes\n        if (value && typeof value === 'object' && 'type' in value) {\n            const marker = `${MARKERS.VNODE}${index}__`;\n            context.vnodes.set(marker, value as VNode);\n            return marker;\n        }\n\n        // Plain values\n        const marker = `${MARKERS.VALUE}${index}__`;\n        context.plainValues.set(marker, value);\n        return marker;\n    }\n\n    /**\n     * Parse HTML string to VNode\n     */\n    function parseHTML(html: string, context: ParseContext): VNode {\n        const config = getConfig();\n\n        let processedHTML = html.trim();\n\n        if (config.sanitizeHTML) {\n            // CRITICAL FIX: Protect event markers BEFORE sanitization\n            // The sanitizer removes onclick=\"...\" attributes, so we need to protect our markers\n            const eventMarkerProtection: { placeholder: string; original: string }[] = [];\n            let protectionIndex = 0;\n\n            // Replace onclick=\"__EVENT_N__\" with a safe placeholder\n            processedHTML = processedHTML.replace(/\\s+(on\\w+)=\"(__EVENT_\\d+__)\"/g, (match, eventName, marker) => {\n                const placeholder = `data-vdom-event-${protectionIndex}=\"${marker}\"`;\n                eventMarkerProtection.push({ placeholder, original: match });\n                protectionIndex++;\n                return ` ${placeholder}`;\n            });\n\n            // Also handle onclick=__EVENT_N__ (without quotes)\n            processedHTML = processedHTML.replace(/\\s+(on\\w+)=(__EVENT_\\d+__)/g, (match, eventName, marker) => {\n                const placeholder = `data-vdom-event-${protectionIndex}=\"${marker}\"`;\n                eventMarkerProtection.push({ placeholder, original: match });\n                protectionIndex++;\n                return ` ${placeholder}`;\n            });\n\n            // Now sanitize\n            processedHTML = sanitizeHTML(processedHTML);\n\n            // Restore event markers\n            for (const { placeholder, original } of eventMarkerProtection) {\n                processedHTML = processedHTML.replace(placeholder, original);\n            }\n        }\n\n        const template = document.createElement('template');\n        template.innerHTML = processedHTML;\n\n        const element = template.content.firstChild as HTMLElement;\n\n        if (!element) {\n            return createElement('div', {}, '');\n        }\n\n        const result = convertDOMToVNode(element, context);\n\n        // If result is a string (text node), wrap it in a span\n        if (typeof result === 'string') {\n            return createElement('span', {}, result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Convert DOM node to VNode\n     */\n    function convertDOMToVNode(element: Node, context: ParseContext): VNode | string {\n        // Text nodes\n        if (element.nodeType === Node.TEXT_NODE) {\n            return handleTextNode(element.textContent || '', context);\n        }\n\n        // Skip non-element nodes\n        if (element.nodeType !== Node.ELEMENT_NODE) {\n            return '';\n        }\n\n        const el = element as HTMLElement;\n        const props = parseAttributes(el.attributes, context);\n        const children = parseChildren(el.childNodes, context) as VNodeChild[];\n\n        return {\n            type: el.tagName.toLowerCase(),\n            props,\n            children,\n        };\n    }\n\n    /**\n     * Handle text node with markers\n     */\n    function handleTextNode(text: string, context: ParseContext): VNode | string {\n        // Check for array markers\n        for (const [marker, array] of context.arrays) {\n            if (text.includes(marker)) {\n                return {\n                    type: 'fragment',\n                    props: {},\n                    children: array.filter(item => !isNullOrBoolean(item)) as VNodeChild[],\n                };\n            }\n        }\n\n        // Check for VNode markers\n        for (const [marker, vnode] of context.vnodes) {\n            if (text.includes(marker)) {\n                return vnode;\n            }\n        }\n\n        // Replace value markers\n        let processedText = text;\n        for (const [marker, value] of context.plainValues) {\n            processedText = processedText.replace(marker, String(value));\n        }\n\n        return processedText;\n    }\n\n    /**\n     * Parse element attributes\n     * IMPORTANT: Just store the raw marker values for event handlers\n     * We'll replace them with actual functions in applyEventHandlers\n     */\n    function parseAttributes(\n        attributes: NamedNodeMap,\n        context: ParseContext\n    ): Record<string, unknown> {\n        const props: Record<string, unknown> = {};\n\n        for (const attr of Array.from(attributes)) {\n            const { name, value } = attr;\n\n            // Event handlers - keep the marker string as-is\n            // It will be replaced by applyEventHandlers later\n            if (name.startsWith('on')) {\n                props[name] = value;\n                continue;\n            }\n\n            // Class names\n            if (name === 'class') {\n                props.className = replaceMarkers(value, context.plainValues).trim();\n                continue;\n            }\n\n            // Boolean attributes\n            if (name === 'checked' || name === 'disabled' || name === 'selected' || name === 'required') {\n                const replaced = replaceMarkers(value, context.plainValues);\n\n                if (replaced === 'false') {\n                    continue;\n                } else if (replaced === 'true' || replaced === '') {\n                    props[name] = true;\n                } else {\n                    props[name] = replaced;\n                }\n                continue;\n            }\n\n            // Regular attributes\n            props[name] = replaceMarkers(value, context.plainValues);\n        }\n\n        return props;\n    }\n\n    /**\n     * Parse child nodes\n     */\n    function parseChildren(childNodes: NodeListOf<ChildNode>, context: ParseContext): unknown[] {\n        const children: unknown[] = [];\n\n        for (const child of Array.from(childNodes)) {\n            if (child.nodeType === Node.TEXT_NODE) {\n                const text = child.textContent || '';\n\n                // Check for array markers\n                let foundArray = false;\n                for (const [marker, array] of context.arrays) {\n                    if (text.includes(marker)) {\n                        children.push(...array.filter(item => !isNullOrBoolean(item)));\n                        foundArray = true;\n                        break;\n                    }\n                }\n                if (foundArray) continue;\n\n                // Check for VNode markers\n                const foundVNodes: unknown[] = [];\n                for (const [marker, vnode] of context.vnodes) {\n                    if (text.includes(marker)) {\n                        if (vnode && typeof vnode === 'object' && 'type' in vnode) {\n                            foundVNodes.push(vnode);\n                        }\n                    }\n                }\n                if (foundVNodes.length > 0) {\n                    children.push(...foundVNodes);\n                    continue;\n                }\n\n                // Add processed text\n                if (text.trim()) {\n                    const processedText = replaceMarkers(text, context.plainValues);\n                    if (processedText.trim()) {\n                        children.push(processedText);\n                    }\n                }\n            } else if (child.nodeType === Node.ELEMENT_NODE) {\n                const converted = convertDOMToVNode(child, context);\n                if (converted) children.push(converted);\n            }\n        }\n\n        return children;\n    }\n\n    /**\n     * Replace markers in string with actual values\n     */\n    function replaceMarkers(str: string, valueMap: Map<string, unknown>): string {\n        let result = str;\n        for (const [marker, value] of valueMap) {\n            result = result.replace(marker, String(value));\n        }\n        return result;\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/props.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNodeProps, StyleObject } from '../types';\n    import { isEventProp, getEventName, isFunction } from '../utils/helpers';\n    import { warn } from '../utils/errors';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Boolean attributes that work differently\n     */\n    const BOOLEAN_ATTRS = new Set([\n        'checked',\n        'selected',\n        'disabled',\n        'readOnly',\n        'required',\n        'autoFocus',\n        'multiple',\n        'hidden',\n        'autoplay',\n        'controls',\n        'loop',\n        'muted',\n        'open',\n        'reversed'\n    ]);\n\n    /**\n     * Update element properties\n     */\n    export function updateProps(\n        element: HTMLElement,\n        oldProps: VNodeProps,\n        newProps: VNodeProps\n    ): void {\n        // Remove old props\n        for (const key in oldProps) {\n            if (!(key in newProps)) {\n                removeProperty(element, key, oldProps[key]);\n            }\n        }\n\n        // Set new props\n        for (const [key, value] of Object.entries(newProps)) {\n            if (oldProps[key] !== value) {\n                setProperty(element, key, value, oldProps[key]);\n            }\n        }\n    }\n\n    /**\n     * Set a single property on element\n     */\n    export function setProperty(\n        element: HTMLElement,\n        key: string,\n        value: unknown,\n        oldValue?: unknown\n    ): void {\n        // Skip special keys\n        if (key === 'children' || key === 'key') return;\n\n        // Event handlers\n        if (isEventProp(key)) {\n            setEventListener(element, key, value, oldValue);\n            return;\n        }\n\n        // Ref callback\n        if (key === 'ref' && isFunction(value)) {\n            value(element);\n            return;\n        }\n\n        // Class name\n        if (key === 'className' || key === 'class') {\n            setClassName(element, value);\n            return;\n        }\n\n        // Style\n        if (key === 'style') {\n            setStyle(element, value as StyleObject | null | undefined);\n            return;\n        }\n\n        // Dangerous HTML\n        const __value = value as { __html: string } | undefined;\n        if (key === 'dangerouslySetInnerHTML' && __value?.__html) {\n            element.innerHTML = __value?.__html;\n            return;\n        }\n\n        // Boolean attributes\n        if (BOOLEAN_ATTRS.has(key)) {\n            setBooleanAttribute(element, key, value);\n            return;\n        }\n\n        // Regular attributes\n        setAttribute(element, key, value);\n    }\n\n    /**\n     * Remove a property from element\n     */\n    export function removeProperty(element: HTMLElement, key: string, oldValue: unknown): void {\n        // Event handlers\n        if (isEventProp(key) && isFunction(oldValue)) {\n            const eventName = getEventName(key);\n            element.removeEventListener(eventName, oldValue as EventListenerOrEventListenerObject);\n            return;\n        }\n\n        // Ref\n        if (key === 'ref' && isFunction(oldValue)) {\n            oldValue(null);\n            return;\n        }\n\n        // Class name\n        if (key === 'className' || key === 'class') {\n            element.className = '';\n            element.removeAttribute('class');\n            return;\n        }\n\n        // Style\n        if (key === 'style') {\n            element.removeAttribute('style');\n            return;\n        }\n\n        // Boolean attributes\n        if (BOOLEAN_ATTRS.has(key)) {\n            element.removeAttribute(key.toLowerCase());\n            return;\n        }\n\n        // Regular attributes\n        element.removeAttribute(key);\n    }\n\n    /**\n     * Set event listener\n     */\n    function setEventListener(\n        element: HTMLElement,\n        propName: string,\n        handler: unknown,\n        oldHandler?: unknown\n    ): void {\n        if (!isFunction(handler)) {\n            if (process.env.NODE_ENV !== 'production') {\n                warn(`Event handler ${propName} is not a function`);\n            }\n            return;\n        }\n\n        const eventName = getEventName(propName);\n\n        // Remove old handler\n        if (oldHandler && isFunction(oldHandler)) {\n            element.removeEventListener(eventName, oldHandler as EventListenerOrEventListenerObject);\n        }\n\n        // Add new handler\n        element.addEventListener(eventName, handler as EventListenerOrEventListenerObject);\n    }\n\n    /**\n     * Set class name\n     */\n    function setClassName(element: HTMLElement, value: unknown): void {\n        if (value == null || value === false) {\n            element.className = '';\n            element.removeAttribute('class');\n            return;\n        }\n\n        const className = String(value).trim();\n        if (className) {\n            element.className = className;\n        } else {\n            element.className = '';\n            element.removeAttribute('class');\n        }\n    }\n\n    type SetStyleValueType = string | StyleObject | null | undefined;\n    /**\n     * Set style attribute\n     */\n    function setStyle(element: HTMLElement, value: SetStyleValueType): void {\n        if (value == null) {\n            element.removeAttribute('style');\n            return;\n        }\n\n        // String style\n        if (typeof value === 'string') {\n            element.setAttribute('style', value);\n            return;\n        }\n\n        // Object style\n        if (typeof value === 'object') {\n            for (const [prop, val] of Object.entries(value)) {\n                if (val == null) {\n                    (element.style as StyleObject)[prop] = '';\n                } else {\n                    (element.style as StyleObject)[prop] = val as string;\n                }\n            }\n        }\n    }\n\n    /**\n     * Set boolean attribute\n     *\n     * FIXED: Treat any value except false, null, undefined as true\n     * This matches HTML spec and common framework behavior\n     * Special case: empty string '' is valid and sets the attribute\n     */\n    function setBooleanAttribute(element: HTMLElement, key: string, value: unknown): void {\n        const attrName = key.toLowerCase();\n\n        // Explicitly false, null, or undefined removes the attribute\n        if (value === false || value === null || value === undefined) {\n            element.removeAttribute(attrName);\n            return;\n        }\n\n        // Any other value (including empty string '') sets the attribute\n        // This includes: true, 'true', '', 'yes', 'disabled', numbers, etc.\n        element.setAttribute(attrName, '');\n    }\n\n    /**\n     * Set regular attribute\n     */\n    function setAttribute(element: HTMLElement, key: string, value: unknown): void {\n        if (value == null || value === false) {\n            element.removeAttribute(key);\n            return;\n        }\n\n        // Convert to string and set\n        element.setAttribute(key, String(value));\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/render.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode } from '../types';\n    import { isNullOrBoolean, isPrimitive } from '../utils/helpers';\n    import { handleError, createErrorPlaceholder, validateVNode } from '../utils/errors';\n    import { updateProps } from './props';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Create a real DOM element from a VNode\n     *\n     * @param vnode - Virtual node to convert\n     * @returns HTML element, text node, or document fragment\n     */\n    export function createDOMElement(vnode: VNode | string | number): HTMLElement | Text | DocumentFragment {\n        try {\n            // Handle text nodes (primitives)\n            if (isPrimitive(vnode)) {\n                return document.createTextNode(String(vnode));\n            }\n\n            // Validate VNode structure\n            if (!validateVNode(vnode)) {\n                throw new Error('Invalid VNode structure');\n            }\n\n            // Handle fragments\n            if (vnode.type === 'fragment') {\n                return createFragment(vnode);\n            }\n\n            // Handle regular elements\n            return createRegularElement(vnode);\n\n        } catch (error) {\n            handleError(error as Error, typeof vnode === 'object' ? vnode : undefined, 'createDOMElement');\n            return createErrorPlaceholder(error as Error);\n        }\n    }\n\n    /**\n     * Create a document fragment from VNode\n     */\n    function createFragment(vnode: VNode): DocumentFragment {\n        const fragment = document.createDocumentFragment();\n\n        for (const child of vnode.children) {\n            if (isNullOrBoolean(child)) continue;\n\n            const childElement = isPrimitive(child)\n                ? document.createTextNode(String(child))\n                : createDOMElement(child as VNode);\n\n            fragment.appendChild(childElement);\n        }\n\n        return fragment;\n    }\n\n    /**\n     * Create a regular HTML element from VNode\n     */\n    function createRegularElement(vnode: VNode): HTMLElement {\n        // Create element\n        const element = document.createElement(vnode.type);\n\n        // Set properties\n        updateProps(element, {}, vnode.props);\n\n        // Append children\n        for (const child of vnode.children) {\n            if (isNullOrBoolean(child)) continue;\n\n            const childElement = isPrimitive(child)\n                ? document.createTextNode(String(child))\n                : createDOMElement(child as VNode);\n\n            element.appendChild(childElement);\n        }\n\n        return element;\n    }\n\n    /**\n     * Main render function - renders VNode to container\n     *\n     * @param vnode - Virtual node to render\n     * @param container - Container element\n     *\n     * @example\n     * ```ts\n     * const app = createElement('div', {}, 'Hello World');\n     * render(app, document.getElementById('root')!);\n     * ```\n     */\n    export function render(vnode: VNode, container: HTMLElement): void {\n        try {\n            // Clear container\n            container.innerHTML = '';\n\n            // Create and append element\n            const element = createDOMElement(vnode);\n            container.appendChild(element);\n\n        } catch (error) {\n            handleError(error as Error, vnode, 'render');\n        }\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// src/core/patch.ts\n//\n// Made with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { VNode, VNodeChild } from '../types';\n    import { isNullOrBoolean, isPrimitive, getChildAt } from '../utils/helpers';\n    import { handleError } from '../utils/errors';\n    import { createDOMElement } from './render';\n    import { updateProps } from './props';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ HELP ════════════════════════════════════════╗\n\n    /**\n     * Patch a single child\n     */\n    function patchChild(\n        parent: HTMLElement,\n        oldChild: VNodeChild,\n        newChild: VNodeChild,\n        index: number\n    ): void {\n        // Skip null/boolean children\n        if (isNullOrBoolean(newChild)) {\n            if (!isNullOrBoolean(oldChild)) {\n                const node = parent.childNodes[index];\n                if (node) parent.removeChild(node);\n            }\n            return;\n        }\n\n        // Convert to proper types for patch function\n        const oldVNode = isNullOrBoolean(oldChild) ? null : oldChild;\n        patch(parent, oldVNode, newChild, index);\n    }\n\n    /**\n     * Patch children by index (simple diffing without keys)\n     */\n    export function patchChildrenByIndex(\n        parent: HTMLElement,\n        oldChildren: VNodeChild[],\n        newChildren: VNodeChild[]\n    ): void {\n        const maxLength = Math.max(oldChildren.length, newChildren.length);\n\n        // Patch each child\n        for (const i of Array.from({ length: maxLength }, (_, idx) => idx)) {\n            patchChild(parent, oldChildren[i], newChildren[i], i);\n        }\n\n        // Remove excess children\n        while (parent.childNodes.length > newChildren.filter(c => !isNullOrBoolean(c)).length) {\n            const lastChild = parent.lastChild;\n            if (lastChild) parent.removeChild(lastChild);\n        }\n    }\n\n    /**\n     * Patch children with keys (optimized diffing)\n     * Properly map VNode children to DOM elements\n     */\n    export function patchChildrenWithKeys(\n        parent: HTMLElement,\n        oldChildren: VNodeChild[],\n        newChildren: VNodeChild[]\n    ): void {\n        // Step 1: Build map of old keyed elements\n        // CRITICAL FIX: Only use ELEMENT nodes, not all childNodes\n        const oldKeyMap = new Map<unknown, { vnode: VNode; element: HTMLElement }>();\n\n        // Get only element children (skip text nodes)\n        const domElements: HTMLElement[] = [];\n        for (const child of Array.from(parent.children)) {\n            domElements.push(child as HTMLElement);\n        }\n\n        // Match VNode children with DOM elements\n        let elementIndex = 0;\n        for (const child of oldChildren) {\n            if (isNullOrBoolean(child)) continue;\n            if (isPrimitive(child)) continue; // Skip text nodes in VNode children\n\n            const vnode = child as VNode;\n            const element = domElements[elementIndex];\n\n            if (!element) break;\n\n            if (vnode.props.key != null) {\n                const key = vnode.props.key;\n                oldKeyMap.set(key, { vnode, element });\n            }\n            elementIndex++;\n        }\n\n        // Step 2: Build the new DOM structure\n        const newElements: Node[] = [];\n\n        for (const newChild of newChildren) {\n            if (isNullOrBoolean(newChild)) continue;\n\n            // Handle text nodes\n            if (isPrimitive(newChild)) {\n                const textNode = document.createTextNode(String(newChild));\n                newElements.push(textNode);\n                continue;\n            }\n\n            const newVNode = newChild as VNode;\n            const key = newVNode.props.key;\n\n            // Try to reuse existing keyed element\n            if (key != null && oldKeyMap.has(key)) {\n                const { vnode: oldVNode, element } = oldKeyMap.get(key)!;\n\n                // Update the existing element\n                updateProps(element, oldVNode.props, newVNode.props);\n\n                // Recursively patch children\n                const oldChildrenArray = oldVNode.children || [];\n                const newChildrenArray = newVNode.children || [];\n\n                const childrenHaveKeys = newChildrenArray.some(\n                    c => c && typeof c === 'object' && 'props' in c && c.props.key != null\n                );\n\n                if (childrenHaveKeys) {\n                    patchChildrenWithKeys(element, oldChildrenArray, newChildrenArray);\n                } else {\n                    patchChildrenByIndex(element, oldChildrenArray, newChildrenArray);\n                }\n\n                newElements.push(element);\n                // Mark as used by deleting from map\n                oldKeyMap.delete(key);\n            } else {\n                // Create new element\n                const newElement = createDOMElement(newVNode);\n                newElements.push(newElement);\n            }\n        }\n\n        // Step 3: Update the DOM to match the new order\n        // Remove all children first\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n\n        // Append in the correct order\n        for (const element of newElements) {\n            parent.appendChild(element);\n        }\n    }\n\n    /**\n     * Patch children - decides between keyed and simple patching\n     */\n    export function patchChildren(\n        parent: HTMLElement,\n        oldChildren: VNodeChild[],\n        newChildren: VNodeChild[]\n    ): void {\n        // Check if we should use keyed diffing\n        const hasKeys = newChildren.some(child =>\n            child && typeof child === 'object' && 'props' in child && child.props.key != null\n        );\n\n        if (hasKeys) {\n            patchChildrenWithKeys(parent, oldChildren, newChildren);\n        } else {\n            patchChildrenByIndex(parent, oldChildren, newChildren);\n        }\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\n\n    /**\n     * Add a new node to parent\n     */\n    function addNode(parent: HTMLElement, vnode: VNode | string | number): void {\n        const element = createDOMElement(vnode);\n        parent.appendChild(element);\n    }\n\n    /**\n     * Remove a node from parent\n     */\n    function removeNode(parent: HTMLElement, node: Node | undefined): void {\n        if (node && node.parentNode === parent) {\n            parent.removeChild(node);\n        }\n    }\n\n    /**\n     * Update text node\n     */\n    function updateTextNode(\n        parent: HTMLElement,\n        oldText: string | number,\n        newText: string | number,\n        index: number,\n        oldChild: Node | undefined\n    ): void {\n        const oldStr = String(oldText);\n        const newStr = String(newText);\n\n        if (oldStr === newStr) return;\n\n        if (oldChild?.nodeType === Node.TEXT_NODE) {\n            oldChild.textContent = newStr;\n        } else {\n            const textNode = document.createTextNode(newStr);\n            if (oldChild) {\n                parent.replaceChild(textNode, oldChild);\n            } else {\n                parent.appendChild(textNode);\n            }\n        }\n    }\n\n    /**\n     * Replace node completely\n     */\n    function replaceNode(\n        parent: HTMLElement,\n        newVNode: VNode | string | number,\n        oldChild: Node | undefined\n    ): void {\n        const newElement = createDOMElement(newVNode);\n\n        if (oldChild) {\n            parent.replaceChild(newElement, oldChild);\n        } else {\n            parent.appendChild(newElement);\n        }\n    }\n\n    /**\n     * Check if VNode has changed (needs replacement)\n     */\n    function hasVNodeChanged(oldVNode: VNode, newVNode: VNode): boolean {\n        return (\n            oldVNode.type !== newVNode.type ||\n            oldVNode.props.key !== newVNode.props.key\n        );\n    }\n\n    /**\n     * Update element in place\n     * FIXED: Detect if we're patching the parent element itself vs its children\n     */\n    function updateElement(\n        parent: HTMLElement,\n        oldVNode: VNode,\n        newVNode: VNode,\n        index: number,\n        oldChild: Node | undefined\n    ): void {\n        let elementToUpdate: HTMLElement;\n\n        // CRITICAL: Check if we're patching the parent element itself\n        // This happens when parent's tag matches BOTH VNode types\n        // AND the oldChild either doesn't exist OR has a different tag than the VNode\n        // This pattern: patch(ul, ulVNode, ulVNode, 0) where we want to update ul's children\n        const parentMatchesVNode = parent.tagName.toLowerCase() === oldVNode.type &&\n                                   parent.tagName.toLowerCase() === newVNode.type;\n        const childIsDifferentType = oldChild instanceof HTMLElement &&\n                                    oldChild.tagName.toLowerCase() !== oldVNode.type;\n\n        if (parentMatchesVNode && (!oldChild || childIsDifferentType)) {\n            // We're updating the parent element itself, not a child\n            elementToUpdate = parent;\n        } else if (oldChild instanceof HTMLElement) {\n            // We're updating a child element\n            elementToUpdate = oldChild;\n        } else {\n            // Fallback: replace the node\n            replaceNode(parent, newVNode, oldChild);\n            return;\n        }\n\n        // Update props\n        updateProps(elementToUpdate, oldVNode.props, newVNode.props);\n\n        // Update children\n        const oldChildren = oldVNode.children || [];\n        const newChildren = newVNode.children || [];\n\n        patchChildren(elementToUpdate, oldChildren, newChildren);\n    }\n\n    /**\n     * Update existing node or replace if needed\n     */\n    function updateNode(\n        parent: HTMLElement,\n        oldVNode: VNode | string | number,\n        newVNode: VNode | string | number,\n        index: number,\n        oldChild: Node | undefined\n    ): void {\n        // Both are primitives (text nodes)\n        if (isPrimitive(oldVNode) && isPrimitive(newVNode)) {\n            updateTextNode(parent, oldVNode, newVNode, index, oldChild);\n            return;\n        }\n\n        // Type changed or one is primitive - replace completely\n        if (\n            (isPrimitive(oldVNode) && !isPrimitive(newVNode)) ||\n            (!isPrimitive(oldVNode) && isPrimitive(newVNode)) ||\n            hasVNodeChanged(oldVNode as VNode, newVNode as VNode)\n        ) {\n            replaceNode(parent, newVNode, oldChild);\n            return;\n        }\n\n        // Both are VNodes of same type - update in place\n        if (!isPrimitive(oldVNode) && !isPrimitive(newVNode)) {\n            updateElement(parent, oldVNode as VNode, newVNode as VNode, index, oldChild);\n        }\n    }\n\n    /**\n     * Patch/diff algorithm - updates DOM based on VNode changes\n     *\n     * @param parent - Parent HTML element\n     * @param oldVNode - Old virtual node\n     * @param newVNode - New virtual node\n     * @param index - Child index in parent\n     */\n    export function patch(\n        parent: HTMLElement,\n        oldVNode: VNode | string | number | null,\n        newVNode: VNode | string | number | null,\n        index: number = 0\n    ): void {\n        try {\n            const oldChild = getChildAt(parent, index);\n\n            // Case 1: Add new node\n            if (!oldVNode && newVNode) {\n                addNode(parent, newVNode);\n                return;\n            }\n\n            // Case 2: Remove old node\n            if (oldVNode && !newVNode) {\n                removeNode(parent, oldChild);\n                return;\n            }\n\n            // Case 3: Both exist - update or replace\n            if (oldVNode && newVNode) {\n                updateNode(parent, oldVNode, newVNode, index, oldChild);\n            }\n\n        } catch (error) {\n            handleError(\n                error as Error,\n                typeof newVNode === 'object' && newVNode !== null ? newVNode : undefined,\n                'patch'\n            );\n        }\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n"]}